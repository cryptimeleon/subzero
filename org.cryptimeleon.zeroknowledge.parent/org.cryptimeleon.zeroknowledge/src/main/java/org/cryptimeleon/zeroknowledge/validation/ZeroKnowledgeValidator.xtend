/*
 * generated by Xtext 2.24.0
 */
package org.cryptimeleon.zeroknowledge.validation

import java.util.ArrayList
import java.util.HashSet
import java.util.Iterator
import java.util.List
import java.util.Map
import java.util.Set
import org.cryptimeleon.zeroknowledge.model.AugmentedModel
import org.cryptimeleon.zeroknowledge.model.BranchState
import org.cryptimeleon.zeroknowledge.model.FunctionSignature
import org.cryptimeleon.zeroknowledge.model.GroupType
import org.cryptimeleon.zeroknowledge.model.ModelHelper
import org.cryptimeleon.zeroknowledge.model.ModelMap
import org.cryptimeleon.zeroknowledge.model.Type
import org.cryptimeleon.zeroknowledge.predefined.PredefinedFunctionsHelper
import org.cryptimeleon.zeroknowledge.zeroKnowledge.Argument
import org.cryptimeleon.zeroknowledge.zeroKnowledge.Brackets
import org.cryptimeleon.zeroknowledge.zeroKnowledge.Comparison
import org.cryptimeleon.zeroknowledge.zeroKnowledge.Conjunction
import org.cryptimeleon.zeroknowledge.zeroKnowledge.Disjunction
import org.cryptimeleon.zeroknowledge.zeroKnowledge.Expression
import org.cryptimeleon.zeroknowledge.zeroKnowledge.FunctionCall
import org.cryptimeleon.zeroknowledge.zeroKnowledge.FunctionDefinition
import org.cryptimeleon.zeroknowledge.zeroKnowledge.LocalVariable
import org.cryptimeleon.zeroknowledge.zeroKnowledge.Model
import org.cryptimeleon.zeroknowledge.zeroKnowledge.Negative
import org.cryptimeleon.zeroknowledge.zeroKnowledge.NumberLiteral
import org.cryptimeleon.zeroknowledge.zeroKnowledge.Parameter
import org.cryptimeleon.zeroknowledge.zeroKnowledge.ParameterList
import org.cryptimeleon.zeroknowledge.zeroKnowledge.Power
import org.cryptimeleon.zeroknowledge.zeroKnowledge.Product
import org.cryptimeleon.zeroknowledge.zeroKnowledge.PublicParameter
import org.cryptimeleon.zeroknowledge.zeroKnowledge.PublicParameterList
import org.cryptimeleon.zeroknowledge.zeroKnowledge.StringLiteral
import org.cryptimeleon.zeroknowledge.zeroKnowledge.Sum
import org.cryptimeleon.zeroknowledge.zeroKnowledge.Tuple
import org.cryptimeleon.zeroknowledge.zeroKnowledge.Variable
import org.cryptimeleon.zeroknowledge.zeroKnowledge.Witness
import org.cryptimeleon.zeroknowledge.zeroKnowledge.WitnessList
import org.cryptimeleon.zeroknowledge.zeroKnowledge.ZeroKnowledgePackage
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.validation.Check
import org.cryptimeleon.zeroknowledge.zeroKnowledge.WitnessVariable
import java.util.HashMap
import java.util.Map.Entry

/**
 * This class contains custom validation rules for validating the syntax tree
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 * 
 * The language grammar specification is designed to be less strict, with stricter rules
 * instead applied during validation. This allows for more descriptive errors/warnings in
 * the editor, as opposed to generating less descriptive syntax errors
 */
class ZeroKnowledgeValidator extends AbstractZeroKnowledgeValidator {
	
	var Map<EObject, Type> types;
	var Map<EObject, Integer> sizes;
	var Map<String, GroupType> groupsByName;
	var Map<String, FunctionSignature> userFunctions;
	var Map<String, FunctionSignature> predefinedFunctions;
	var Set<String> witnessNames;
	var Set<String> publicParameterNames;
	
	/*
	 * Validation proceeds in a topdown, preorder traversal of the syntax tree,
	 * starting at the root Model node.
	 * 
	 * checkModel is the only function with the @Check annotation (it will be called by the EValidator)
	 * checkNode is a dispatch function to call the corresponding validation functions for each
	 * different type of syntax tree nodes
	 * Any other function prefixed with 'check' can create validation errors or warnings
	 * All other functions are helper functions
	 */
	@Check
	def void checkModel(Model model) {
		val AugmentedModel augmentedModel = new AugmentedModel(model);
		
		types = augmentedModel.getTypes();
		sizes = augmentedModel.getSizes();
		groupsByName = augmentedModel.getGroupsByName();
		userFunctions = augmentedModel.getUserFunctionSignatures();
		predefinedFunctions = PredefinedFunctionsHelper.getAllPredefinedFunctions();
		witnessNames = augmentedModel.getWitnessNames();
		publicParameterNames = augmentedModel.getPublicParameterNames();
		
		System.out.println("Validating the model");

		// Iterate over the tree in a preorder traversal and perform validation on each node
		ModelMap.preorderWithState(model, new BranchState(), [EObject node, BranchState state |
			checkNode(node, state);
		]);
	}
	
	def dispatch void checkNode(Model model, BranchState state) {
		checkFunctionNamesAreUnique(model);
		checkSubprotocolNamesAreUnique(model);
		checkOrWithAndAncestorGroupElementWitnesses(model);
		checkHasProof(model);
	}
	
	def dispatch void checkNode(FunctionDefinition function, BranchState state) {
		checkFunctionNameFormat(function);
		checkFunctionNameIsNotPredefined(function);
		checkFunctionIsCalled(function);
		checkFunctionParametersAreUsed(function);
		checkFunctionHasNoDisjunction(function);
	}

	def dispatch void checkNode(ParameterList parameterList, BranchState state) {
		checkFunctionParameterNamesAreUnique(parameterList);
	}
	
	def dispatch void checkNode(Parameter parameter, BranchState state) {
		checkParameterNameFormat(parameter);
	}
	
	def dispatch void checkNode(PublicParameterList publicParameterList, BranchState state) {
		checkPublicParameterNamesAreUnique(publicParameterList);
	}
	
	def dispatch void checkNode(PublicParameter publicParameter, BranchState state) {
		checkPublicParameterNameFormat(publicParameter);
	}
	
	def dispatch void checkNode(WitnessList witnessList, BranchState state) {
		checkWitnessListIsNonempty(witnessList);
		checkWitnessNamesAreUnique(witnessList);
	}
	
	def dispatch void checkNode(Witness witness, BranchState state) {
		checkWitnessNameFormat(witness);
	}
	
	def dispatch void checkNode(Conjunction conjunction, BranchState state) {
		checkValidConjunctionPosition(conjunction, state);
		checkIsBoolean(conjunction);
		checkConjunctionOperands(conjunction);
		checkIsScalar(conjunction);
	}
	
	def dispatch void checkNode(Disjunction disjunction, BranchState state) {
		checkValidDisjunctionPosition(disjunction, state);
		checkIsBoolean(disjunction);
		checkDisjunctionOperands(disjunction);
		checkIsScalar(disjunction);
	}
	
	def dispatch void checkNode(Comparison comparison, BranchState state) {
		checkComparisonOperations(comparison);
		checkValidComparisonPosition(comparison, state);
		checkIsBoolean(comparison);
		checkComparisonOperands(comparison);
		checkIsScalar(comparison);
	}
	
	def dispatch void checkNode(Sum sum, BranchState state) {
		checkProofAlgebraicPosition(sum, state);
		checkValidAlgebraicPosition(sum, state);
		checkIsExponent(sum);
		checkSumOperands(sum);
	}
	
	def dispatch void checkNode(Product product, BranchState state) {
		checkProofAlgebraicPosition(product, state);
		checkValidAlgebraicPosition(product, state);
		checkProductOperands(product);
	}
	
	def dispatch void checkNode(Power power, BranchState state) {
		checkWitnessIsNotInExponentOfWitness(power);
		checkProofAlgebraicPosition(power, state);
		checkValidAlgebraicPosition(power, state);
		checkIsExponent(power.getRight());
		checkPowerOperands(power);
	}
	
	def dispatch void checkNode(StringLiteral stringLiteral, BranchState state) {
		checkValidStringLiteralPosition(stringLiteral, state);
		checkIsString(stringLiteral);
		checkIsScalar(stringLiteral);
	}
	
	def dispatch void checkNode(Tuple tuple, BranchState state) {
		checkProofAlgebraicPosition(tuple, state);
		checkTupleElementsAreSameType(tuple);
		checkValidTuplePosition(tuple, state);
		checkTupleSize(tuple);
		checkIsTuple(tuple);
	}
	
	def dispatch void checkNode(Negative negative, BranchState state) {
		checkProofAlgebraicPosition(negative, state);
		checkIsExponent(negative);
	}
	
	def dispatch void checkNode(FunctionCall call, BranchState state) {
		checkValidFunctionCall(call);
		checkFunctionHasNoUserFunctionCalls(call, state);
		checkValidFunctionCallPosition(call, state);
		checkPredefinedFunctionCallType(call);
	}
	
	def dispatch void checkNode(Argument argument, BranchState state) {
	}
	
	def dispatch void checkNode(Variable variable, BranchState state) {
		checkVariableNameFormat(variable);
		checkProofAlgebraicPosition(variable, state);
		checkValidGroup(variable);
	}
	
	def dispatch void checkNode(NumberLiteral numberLiteral, BranchState state) {
		checkProofAlgebraicPosition(numberLiteral, state);
		checkIsExponent(numberLiteral);
		checkIsScalar(numberLiteral);
	}
	
	def dispatch void checkNode(Brackets brackets, BranchState state) {
		checkProofAlgebraicPosition(brackets, state);
	}
	
	def dispatch void checkNode(EObject node, BranchState state) {
		System.out.println("Error: unhandled node type in validator");
	}
	
	/*
	 * Validate the format of identifier names
	 */
	 
	// User defined function names must start with a letter, and contain only letters and numbers
	def private void checkFunctionNameFormat(FunctionDefinition function) {
		if (function.getName().contains("_")) {
			error("Function names cannot contain underscores", function,
				getStructuralFeature(function));
		}
		if (function.getName().contains("'")) {
			error("Function names cannot contain single quotes", function,
				getStructuralFeature(function));
		}
	}
	
	// Public parameter names must start with a letter, and only contain letters, numbers, at most 1 underscore
	// (to denote subscript) and any number of single quotes at the end
	def private void checkPublicParameterNameFormat(PublicParameter publicParameter) {
		var List<String> errors = nameFormatErrors(publicParameter.getName(), "Witness");
		for (val Iterator<String> iterator = errors.iterator(); iterator.hasNext();) {
			error(iterator.next(), publicParameter, getStructuralFeature(publicParameter));
		}
	}

	// Witness names must start with a letter, and only contain letters, numbers, at most 1 underscore
	// (to denote subscript) and any number of single quotes at the end
	def private void checkWitnessNameFormat(Witness witness) {
		var List<String> errors = nameFormatErrors(witness.getName(), "Witness");
		for (val Iterator<String> iterator = errors.iterator(); iterator.hasNext();) {
			error(iterator.next(), witness, getStructuralFeature(witness));
		}
	}

	// Variable names must start with a letter, and only contain letters, numbers, at most 1 underscore
	// (to denote subscript) and any number of single quotes at the end
	def private void checkVariableNameFormat(Variable variable) {
		var List<String> errors = nameFormatErrors(variable.getName(), "Variable");
		for (val Iterator<String> iterator = errors.iterator(); iterator.hasNext();) {
			error(iterator.next(), variable, getStructuralFeature(variable));
		}
	}

	// Parameter names must start with a letter, and only contain letters, numbers, at most 1 underscore
	// (to denote subscript) and any number of single quotes at the end
	def private void checkParameterNameFormat(Parameter parameter) {
		var List<String> name_errors = nameFormatErrors(parameter.getName(), "Parameter");
		for (String name_error : name_errors) {
			error(name_error, parameter, getStructuralFeature(parameter));
		}
	}

	// Helper function for checkWitnessNameFormat, checkVariableNameFormat, checkParameterNameFormat
	def private List<String> nameFormatErrors(String identifier, String type) {
		var List<String> name_errors = new ArrayList<String>();

		var int underscores = 0;
		for (var int i = 0; i < identifier.length(); i++) {
			if (identifier.charAt(i) == '_') {
				underscores++;
				if (underscores > 1) {
					name_errors.add(type + " name can contain at most 1 underscore");
					i = identifier.length();
				}
			}
		}

		var boolean quote = false;
		for (var int i = 0; i < identifier.length(); i++) {
			if (quote && identifier.charAt(i) != '\'') {
				name_errors.add(type + " name can only contain single quotes at the end of the name");
			} else if (identifier.charAt(i) == '\'') {
				quote = true;
			}
		}

		if (identifier.charAt(identifier.length() - 1) == '_') {
			name_errors.add(type + " name cannot end with an underscore");
		}

		return name_errors;
	}

	/*
	 * Validate the uniqueness of identifiers
	 */
	 
	// User defined function names must be unique
	def private void checkFunctionNamesAreUnique(Model model) {
		val Set<String> functions = new HashSet<String>();
		for (FunctionDefinition function : model.getFunctions()) {
			val String name = function.getName();
			if (functions.contains(name)) {
				error("Function names must be unique", function, getStructuralFeature(function));
			} else {
				functions.add(name);
			}
		}
	}
	
	// Subprotocol names must be unique
	def private void checkSubprotocolNamesAreUnique(Model model) {
		val Set<String> subprotocolNames = new HashSet<String>();
		ModelMap.preorder(model.getProof(), [EObject node |
			if (node instanceof Comparison) {
				val String subprotocolName = node.getSubprotocolName();
				if (subprotocolNames.contains(subprotocolName)) {
					error("Subprotocol names must be unique", node, getStructuralFeature(node));
				} else if (subprotocolName !== null && !subprotocolName.isEmpty()) {
					subprotocolNames.add(subprotocolName);
				}
			}
		]);
	}

	// User defined functions cannot have the same name as a predefined function
	def private void checkFunctionNameIsNotPredefined(FunctionDefinition function) {
		if (predefinedFunctions.containsKey(function.getName())) {
			error("Function name is already used by a predefined function", function, getStructuralFeature(function));
		}
	}
	
	// Witness names must be unique
	def private void checkPublicParameterNamesAreUnique(PublicParameterList publicParameterList) {
		val HashSet<String> publicParameters = new HashSet<String>();
		for (PublicParameter publicParameter : publicParameterList.getPublicParameters()) {
			val String name = publicParameter.getName();
			if (publicParameters.contains(name)) {
				error("Public parameter names must be unique", publicParameter, getStructuralFeature(publicParameter));
			} else if (witnessNames.contains(name)) {
				error("Public parameter name conflicts with a witness name", publicParameter, getStructuralFeature(publicParameter));
			} else {
				publicParameters.add(name);				
			}
		}
	}

	// Witness names must be unique
	def private void checkWitnessNamesAreUnique(WitnessList witnessList) {
		val HashSet<String> witnesses = new HashSet<String>();
		for (Witness witness : witnessList.getWitnesses()) {
			val String name = witness.getName();
			if (witnesses.contains(name)) {
				error("Witness names must be unique", witness, getStructuralFeature(witness));
			} else if (publicParameterNames.contains(name)) {
				error("Witness name conflicts with a public parameter name", witness, getStructuralFeature(witness));
			} else {
				witnesses.add(name);				
			}
		}
	}

	// Function parameter names must be unique within a function signature
	def private void checkFunctionParameterNamesAreUnique(ParameterList parameterList) {
		val HashSet<String> parameters = new HashSet<String>();
		for (Parameter parameter : parameterList.getParameters()) {
			val String name = parameter.getName();
			if (parameters.contains(name)) {
				error("Function parameters must be unique within a function's signature", parameter, getStructuralFeature(parameter));
			} else {
				parameters.add(name);
			}
		}
	}

	/*
	 * Validate user function definitions
	 */
	 
	// Function definitions cannot contain function calls to other user functions
	def private void checkFunctionHasNoUserFunctionCalls(FunctionCall call, BranchState state) {
		if (state.hasFunctionDefinitionAncestor() && userFunctions.containsKey(call.getName())) {
			error("Cannot call user functions from within a user function", call, getStructuralFeature(call));
		}
	}

	// Every function parameter should be used at least once in the function definition
	def private void checkFunctionParametersAreUsed(FunctionDefinition function) {
		val HashSet<String> functionVariables = new HashSet<String>();
		
		ModelMap.postorder(function.getBody(), [EObject node |
			if (node instanceof LocalVariable) {
				functionVariables.add(node.getName());
			}
		])
		
		for (Parameter parameter: function.getParameterList().getParameters()) {
			if (!functionVariables.contains(parameter.getName())) {
				warning('''Parameter '«parameter.getName()»' should be used within the function definition''', parameter, getStructuralFeature(parameter));
			}
		}
	}

	// User defined functions should be called at least once in the proof expression
	def private void checkFunctionIsCalled(FunctionDefinition function) {
		val String function_name = function.getName();
		val Model root = ModelHelper.getRoot(function);

		if (!ModelMap.postorderAny(root.getProof(), [ EObject node |
			if (node instanceof FunctionCall) {
				if (node.getName() == function_name) {
					return true;
				}
			}
			return false;
		])) {
			warning(
				"Function is never used in the proof expression, and will not be included in the generated Java code", function,
				getStructuralFeature(function));
		}
	}
	
	// User defined functions cannot currently contain a disjunction
	def private void checkFunctionHasNoDisjunction(FunctionDefinition function) {
		val boolean hasDisjunction = ModelMap.postorderAny(function.getBody(), [EObject node |
			return node instanceof Disjunction;
		]);
		
		if (hasDisjunction) {
			error("Disjunctions are currently not supported in user functions", function, getStructuralFeature(function));
		}
	}
	
	/*
	 * Validate the proof expression
	 */
	def private void checkHasProof(Model model) {
		if (model.getProof() === null) {
			error("Must have a proof statement", model, getStructuralFeature(model));
		}
	}

	/*
	 * Validate the witness list
	 */
	 
	// The witness list must contain at least one witness
	def private void checkWitnessListIsNonempty(WitnessList witnessList) {
		if (witnessList.getWitnesses().size() === 0) {
			error("The witness list must include at least one witness", witnessList,
				getStructuralFeature(witnessList));
		}
	}

	/*
	 * Validate function calls
	 */
	 
	// Function calls must reference either a user defined function or a predefined function
	// The number of arguments in a function call must match the number of parameters in the function definition
	
	def private void checkValidFunctionCall(FunctionCall call) {
		val String name = call.getName();

		if (userFunctions.containsKey(name)) {
			val FunctionSignature signature = userFunctions.get(name);
			checkValidFunctionCallHelper(call, signature);
			return;
		}

		if (predefinedFunctions.containsKey(name)) {
			val FunctionSignature signature = predefinedFunctions.get(name);
			checkValidFunctionCallHelper(call, signature);
			return;
		}
		
		error("Function call references a function that does not exist", call,
			getStructuralFeature(call));
	}
	
	def private void checkValidFunctionCallHelper(FunctionCall call, FunctionSignature signature) {
		if (signature.getParameterCount() !== call.getArguments().size()) {
			error(
				'''The number of arguments in the function call («call.getArguments().size()») must match the number of parameters in the function definition («signature.getParameterCount()»)''', call,
				getStructuralFeature(call));
			return;
		}
		
		val Iterator<Type> parameterTypesIterator = signature.getParameterTypes.iterator();
		val Iterator<Integer> parameterSizesIterator = signature.getParameterSizes.iterator();
		val Iterator<Expression> argumentsIterator = call.getArguments().iterator();
		
		while (parameterTypesIterator.hasNext() && parameterSizesIterator.hasNext() && argumentsIterator.hasNext()) {
			val Type parameterType = parameterTypesIterator.next();
			val int parameterSize = parameterSizesIterator.next();
			val EObject argument = argumentsIterator.next();
			
			if (types.get(argument) !== parameterType) {
				error('''The argument type («types.get(argument)») does not match the function parameter type («parameterType»)''', argument, getStructuralFeature(argument));
			}
			
			if (sizes.get(argument) !== parameterSize) {
				error('''The argument size («sizes.get(argument)») does not match the function parameter size («parameterSize»)''', argument, getStructuralFeature(argument));
			}
		}
	}
	
	/*
	 * Validate grammar structure
	 */
	
	// String literals must be directly nested within a tuple, a comparison, or a function call
	def private void checkValidStringLiteralPosition(StringLiteral stringLiteral, BranchState state) {
		val EObject parent = state.getParent();
		
		if (!(parent instanceof FunctionCall)) {
			error("String literals can only be used as arguments in function calls", stringLiteral, getStructuralFeature(stringLiteral));
		}
		
	}

	// Conjunctions cannot be nested within algebraic expressions or comparison expressions
	def private void checkValidConjunctionPosition(Conjunction conjunction, BranchState state) {
		if (!isValidBooleanPosition(conjunction, state)) {
			error("Conjunctions cannot be nested within algebraic expressions, comparison expressions, or function calls", conjunction,
				getStructuralFeature(conjunction));
		}
	}

	// Disjunctions cannot be nested within algebraic expressions or comparison expressions
	def private void checkValidDisjunctionPosition(Disjunction disjunction, BranchState state) {
		if (!isValidBooleanPosition(disjunction, state)) {
			error("Disjunctions cannot be nested within algebraic expressions, comparison expressions, or function calls", disjunction,
				getStructuralFeature(disjunction));
		}
	}

	// Comparisons cannot be nested within algebraic expressions or comparison expressions
	def private void checkValidComparisonPosition(Comparison comparison, BranchState state) {
		if (!isValidBooleanPosition(comparison, state)) {
			error("Comparisons cannot be nested within algebraic expressions, other comparison expressions, or function calls", comparison,
				getStructuralFeature(comparison));
		}
	}
	
	// Double comparisons cannot use equals or not equals, and inequality operators must be the same direction
	def private void checkComparisonOperations(Comparison comparison) {
		val String operation1 = comparison.getOperation();
		val String operation2 = comparison.getOperation2();
		
		// Check if the comparison is a double comparison
		if (operation2 !== null) {
			
			if (operation1 == "=" || operation1 == "!=" || operation2 == "=" || operation2 == "!=") {
				error("Cannot use = or != in a double comparison", comparison, getStructuralFeature(comparison));
				return
			}
			
			if (operation1.charAt(0) != operation2.charAt(0)) {
				error("Comparison operators in a double comparison must be in the same direction", comparison, getStructuralFeature(comparison));
			}
		}
	}
	
	// Helper function for checkValidConjunctionPosition, checkValidDisjunctionPosition, and checkValidComparisonPosition
	def private boolean isValidBooleanPosition(EObject node, BranchState state) {
		val EObject parent = state.getParent();
		if (parent instanceof Model || parent instanceof FunctionDefinition || parent instanceof Conjunction || parent instanceof Disjunction) {
			return true;
		}
		return false;
	}

	// Algebraic expressions must be nested within a comparison expression before being nested within a propositional expression
	def private void checkValidAlgebraicPosition(EObject node, BranchState state) {
		if (state.hasFunctionDefinitionAncestor() || state.hasFunctionCallAncestor()) return;

		if (state.hasPropositionalBeforeComparison()) {
			error("Algebraic expression must be nested within a comparison expression before being nested within a propositional expression", node, getStructuralFeature(node))
		}
	}

	// Algebraic expressions in the proof expression must be nested within a comparison expression or function call
	def private void checkProofAlgebraicPosition(EObject object, BranchState state) {
		if (state.hasFunctionDefinitionAncestor()) return;
		
		if (!(state.hasComparisonAncestor() || state.hasFunctionCallAncestor())) {
			error("Algebraic expressions in the proof expression must be nested within a comparison expression or function call", object, getStructuralFeature(object));
		}
	}
	
	// Function calls to boolean functions cannot be nested within algebraic expressions, comparison expressions, or other function calls
	def private void checkValidFunctionCallPosition(FunctionCall call, BranchState state) {
		if (types.get(call) === Type.BOOLEAN) {
			if (!isValidBooleanPosition(call, state)) {
				error("Function calls to boolean functions cannot be nested within algebraic expressions, comparison expressions, or other function calls", call, getStructuralFeature(call));
			};
		} else {			
			checkProofAlgebraicPosition(call, state);
		}
	}
	
	def private void checkPredefinedFunctionCallType(FunctionCall call) {
		if (predefinedFunctions.containsKey(call.getName())) {
			val Type currentType = types.get(call);
			val Type correctType = predefinedFunctions.get(call.getName()).getReturnType();
			
			if (currentType !== correctType) {
				error('''Predefined function call should have type «correctType», not type «currentType»''', call, getStructuralFeature(call));
			}
		}
	}
	
	def private void checkWitnessIsNotInExponentOfWitness(Power power) {
		val EObject left = power.getLeft();
		val EObject right = power.getRight();
		
		if (left instanceof WitnessVariable) {
			ModelMap.preorder(right, [EObject node |
				if (node instanceof WitnessVariable) {
					error("A witness cannot be in the exponent of another witness", node, getStructuralFeature(node));
				}
			]);
		}
	}
	
	/*
	 * Validate that the operands of a binary operation are of compatible type
	 */
	 
	def private void checkConjunctionOperands(Conjunction conjunction) {
		val Type leftType = types.get(conjunction.getLeft());
		val Type rightType = types.get(conjunction.getRight());
		
		if (types.get(conjunction.getLeft()) !== Type.BOOLEAN || types.get(conjunction.getRight()) !== Type.BOOLEAN) {
			error('''Conjunction operands must both have type BOOLEAN. The left operand is of type «leftType» but the right operand is of type «rightType»''', conjunction, getStructuralFeature(conjunction));
		}
	} 
	
	def private void checkDisjunctionOperands(Disjunction disjunction) {
		val Type leftType = types.get(disjunction.getLeft());
		val Type rightType = types.get(disjunction.getRight());
		
		if (types.get(disjunction.getLeft()) !== Type.BOOLEAN || types.get(disjunction.getRight()) !== Type.BOOLEAN) {
			error('''Disjunction operands must both have type BOOLEAN. The left operand is of type «leftType» but the right operand is of type «rightType»''', disjunction, getStructuralFeature(disjunction));
		}
	}
	
	def private void checkComparisonOperands(Comparison comparison) {
		val EObject left = comparison.getLeft();
		val EObject right = comparison.getRight();
		val Type leftType = types.get(left);
		val Type rightType = types.get(right);
		val int leftSize = sizes.get(left);
		val int rightSize = sizes.get(right);
		
		val boolean leftHasWitness = ModelHelper.containsWitnessVariable(left);
		val boolean rightHasWitness = ModelHelper.containsWitnessVariable(right);
		
		if (comparison.getOperation2() === null) {
			if (leftType !== rightType) {
				error('''The operands of a comparison node must be the same type. The left operand is of type «leftType» but the right operand is of type «rightType»''', comparison, getStructuralFeature(comparison));
			}
			
			if (leftSize !== rightSize) {
				error('''The operands of a comparison node must be the same size. The left operand is of size «leftSize» but the right operand is of size «rightSize»''', comparison, getStructuralFeature(comparison));
			}
			
			if (ModelHelper.isInequalityComparison(comparison)) {
				if (!leftHasWitness && !rightHasWitness) {
					error("One side of a comparison must be dependent on a witness variable", comparison, getStructuralFeature(comparison));
				}
				
				if (leftHasWitness && rightHasWitness) {
					error("Only one side of a comparison can be dependent on a witness variable", comparison, getStructuralFeature(comparison));
				}
			}
				
		} else {
			val EObject center = comparison.getCenter();
			val Type centerType = types.get(center);
			val int centerSize = sizes.get(center);
			
			val boolean centerHasWitness = ModelHelper.containsWitnessVariable(center);
			
			if (leftType !== centerType || centerType !== rightType) {
				error('''The operands of a comparison node must be the same type. The left operand is of type «leftType», the middle operand is of type «centerType», and the right operand is of type«rightType»''', comparison, getStructuralFeature(comparison));
			}
			
			if (leftSize !== centerSize || centerSize !== rightSize) {
				error('''The operands of a comparison node must be the same size. The left operand is of size «leftSize», the middle operand is of size «centerSize», and the right operand is of size«rightSize»''', comparison, getStructuralFeature(comparison));
			}
			
			if (!centerHasWitness) {
				error("The middle of a double comparison must be dependent on a witness variable", comparison, getStructuralFeature(comparison));
			}
			
			if (leftHasWitness || rightHasWitness) {
				error("Only the middle of a double comparison can be dependent on a witness variable", comparison, getStructuralFeature(comparison));
			}
		}
		
	}
	
	def private void checkSumOperands(Sum sum) {
		val Type leftType = types.get(sum.getLeft());
		val Type rightType = types.get(sum.getRight());
		val int leftSize = sizes.get(sum.getLeft());
		val int rightSize = sizes.get(sum.getRight());
		
		if (leftType !== Type.EXPONENT || rightType !== Type.EXPONENT) {
			error('''Sum operands must both have type EXPONENT. The left operand is of type «leftType» but the right operand is of type «rightType»''', sum, getStructuralFeature(sum));
		}
		
		if (leftSize !== rightSize) {
			error('''The operands of a sum node must be the same size. The left operand is of size «leftSize» but the right operand is of size «rightSize»''', sum, getStructuralFeature(sum));
		}
	}
	
	def private void checkProductOperands(Product product) {
		val Type leftType = types.get(product.getLeft());
		val Type rightType = types.get(product.getRight());
		val int leftSize = sizes.get(product.getLeft());
		val int rightSize = sizes.get(product.getRight());
		
		if (leftType !== rightType) {
			error('''The operands of a product node must be the same type. The left operand is of type «leftType» but the right operand is of type «rightType»''', product, getStructuralFeature(product));
		}
		
		if (leftType === Type.GROUP_ELEMENT && rightType === Type.GROUP_ELEMENT && leftSize !== rightSize) {
			error('''The operands of a GROUP_ELEMENT product node must be the same size. The left operand is of size «leftSize» but the right operand is of size «rightSize»''', product, getStructuralFeature(product));
		}		
	}
	
	def private void checkPowerOperands(Power power) {
		val Type type = types.get(power);
		val Type leftType = types.get(power.getLeft());
		val Type rightType = types.get(power.getRight());
		val int rightTuple = sizes.get(power.getRight());

		if (!(leftType === Type.EXPONENT || leftType === Type.GROUP_ELEMENT)) {
			error('''The left operand of a power node must be of type EXPONENT or GROUP_ELEMENT, not type «leftType»''', power, getStructuralFeature(power));
		}
		
		if (rightType !== Type.EXPONENT) {
			error('''The right operand of a power node must be of type EXPONENT, not type «rightType»''', power, getStructuralFeature(power));
		}
		
		if (type !== leftType) {
			error('''The type of a power node must be the same as the type of the left operand. The power node is of type «type» but the left operand is of type «leftType»''', power, getStructuralFeature(power));
		}
		
		if (rightTuple > 1) {
			error('''The right operand of a power node cannot be a tuple''', power, getStructuralFeature(power));
		}
	}
	
	def private void checkTupleElementsAreSameType(Tuple tuple) {
		val Type tupleType = types.get(tuple);
		
		for (EObject element : tuple.getElements()) {
			val Type elementType = types.get(element);
			
			if (tupleType !== elementType) {
				error('''Tuple elements must be the same type as the tuple. The tuple has type «tupleType», but the element has type «elementType»''', element, getStructuralFeature(element));
			}
		}
	}
	
	// A group element witness cannot be in both subtrees of a disjunction
	// that has a conjunction ancestor
	def private void checkOrWithAndAncestorGroupElementWitnesses(Model model) {
		ModelMap.preorderWithStateAndControl(model.getProof(), new BranchState(), [EObject node, BranchState state, ModelMap.Controller controller |
			if (node instanceof Disjunction && state.hasConjunctionAncestor()) {
				controller.continueTraversal();
				
				val Map<String, List<WitnessVariable>> witnessNodes = new HashMap<String, List<WitnessVariable>>();
				checkOrTreeHelper(node, witnessNodes);
			}
		]);
	}
	
	def private void checkOrTreeHelper(EObject node, Map<String, List<WitnessVariable>> witnessNodes) {
		if (node instanceof WitnessVariable) {
			if (types.get(node) == Type.GROUP_ELEMENT) {
				val String name = node.getName();
				if (witnessNodes.containsKey(name)) {
					witnessNodes.get(name).add(node);
				} else {
					val List<WitnessVariable> variables = new ArrayList<WitnessVariable>();
					variables.add(node);
					witnessNodes.put(name, variables);
				}
			}
			
		} else if (node instanceof Disjunction) {
			var Map<String, List<WitnessVariable>> leftWitnessNodes = new HashMap<String, List<WitnessVariable>>();
			var Map<String, List<WitnessVariable>> rightWitnessNodes = new HashMap<String, List<WitnessVariable>>();
			checkOrTreeHelper(node.getLeft(), leftWitnessNodes);
			checkOrTreeHelper(node.getRight(), rightWitnessNodes);
			
			val Set<String> sharedNames = new HashSet<String>(leftWitnessNodes.keySet());
			sharedNames.retainAll(rightWitnessNodes.keySet());
			
			for (String name : sharedNames) {
				createOrErrors(leftWitnessNodes.get(name));
				createOrErrors(rightWitnessNodes.get(name));
			}
			
			mergeMapsOfLists(witnessNodes, leftWitnessNodes);
			mergeMapsOfLists(witnessNodes, rightWitnessNodes);
		} else {
			for (EObject child : node.eContents()) {
				checkOrTreeHelper(child, witnessNodes);
			}
		}
	}
	
	def private void createOrErrors(List<WitnessVariable> witnessVariables) {
		for (WitnessVariable variable : witnessVariables) {
			error(
				"A group element witness cannot be in both subtrees of a disjunction with a conjunction ancestor",
				variable,
				getStructuralFeature(variable)
			);
		}
	}
	
	def private <K, T> void mergeMapsOfLists(Map<K, List<T>> finalMap, Map<K, List<T>> mergedMap) {
		for (Entry<K, List<T>> entry : mergedMap.entrySet()) {
			val K name = entry.getKey();
			val List<T> list = entry.getValue();
			
			if (finalMap.containsKey(name)) {
				finalMap.get(name).addAll(list);
			} else {
				finalMap.put(name, list);
			}
		}
	}
	
	/*
	 * Validate that nodes with a predetermined type are actually this type
	 */	
	 
	def private void checkIsBoolean(EObject node) {
		checkIsType(node, Type.BOOLEAN);
	}
	
	def private void checkIsExponent(EObject node) {
		checkIsType(node, Type.EXPONENT);
	}
	
	def private void checkIsGroupElement(EObject node) {
		checkIsType(node, Type.GROUP_ELEMENT);
	}
	
	def private void checkIsExponentOrGroupElement(EObject node) {
		if (!types.containsKey(node)) {
			error('''«capitalize(getName(node))» must be of type EXPONENT or GROUP_ELEMENT''', node, getStructuralFeature(node));
		} else {
			error('''«capitalize(getName(node))» must be of type EXPONENT or GROUP_ELEMENT, not type «types.get(node).toString()»''', node, getStructuralFeature(node));
		}
	}
	
	def private void checkIsString(EObject node) {
		checkIsType(node, Type.STRING);
	}
	
	def private void checkIsType(EObject node, Type type) {
		if (!types.containsKey(node)) {
			error('''«capitalize(getName(node))» must be of type «type.toString()»''', node, getStructuralFeature(node));
		} else if (types.get(node) !== type) {
			error('''«capitalize(getName(node))» must be of type «type.toString()», not type «types.get(node).toString()»''', node, getStructuralFeature(node));
		}
	}
	
	def private void checkIsScalar(EObject node) {
		if (!sizes.containsKey(node)) {
			error('''«capitalize(getName(node))» must be a scalar''', node, getStructuralFeature(node));	
		} else if (sizes.get(node) !== 1) {
			error('''«capitalize(getName(node))» must be a scalar, not a tuple of size «sizes.get(node)»''', node, getStructuralFeature(node));
		}
	}
	
	def private void checkIsTuple(EObject node) {
		if (!sizes.containsKey(node)) {
			error('''«capitalize(getName(node))» must be a tuple''', node, getStructuralFeature(node));		
		} else if (sizes.get(node) <= 1) {
			error('''«capitalize(getName(node))» must be a tuple, not a scalar''', node, getStructuralFeature(node));
		}
	}
	
	/*
	 * Validate tuples
	 */
	
	// Tuples must be nested within a function call before being nested within another tuple
	def private void checkValidTuplePosition(Tuple tuple, BranchState state) {
		if (state.hasTupleBeforeFunctionCall()) {
			error('''Tuples must be nested within a function call before being nested within another tuple''', tuple, getStructuralFeature(tuple));
		}
	}
	
	def private void checkTupleSize(Tuple tuple) {
		val int currentSize = sizes.get(tuple);
		val int correctSize = tuple.getElements().size();
		
		if (currentSize !== correctSize) {
			error('''The operands of operations between tuples must have the same size. This tuple of size «correctSize» is in an operation with a tuple of size «currentSize»''', tuple ,getStructuralFeature(tuple));
		}
	}
	
	/*
	 * Validate group types
	 * 
	 */
	 def private void checkValidGroup(Variable variable) {
	 	if (groupsByName.get(variable.getName()) === GroupType.UNKNOWN) {
	 		error("Variable is used in conflicting group element contexts", variable, getStructuralFeature(variable));
	 	}
	 }
	 
	
	/*
	 * Additional helper functions
	 */	
	
	// Capitalizes the first letter of the string
	def private String capitalize(String string) {
		if (string === "") return "";
		return string.substring(0, 1).toUpperCase() + string.substring(1);
	}
	
	// Returns the name of the type of node
	def private String getName(EObject object) {
		switch object {
			Model:				return "model"
			FunctionDefinition:	return "function definition"
			ParameterList:		return "parameter list"
			Parameter:			return "parameter"
			WitnessList:		return "witness list"
			Witness:			return "witness"
			Conjunction: 		return "conjunction"
			Disjunction: 		return "disjunction"
			Comparison: 		return "comparison"
			Sum: 				return "sum"
			Product: 			return "product"
			Power: 				return "power"
			StringLiteral: 		return "string literal"
			Tuple: 				return "tuple"
			Negative: 			return "negative"
			FunctionCall: 		return "function call"
			Argument:			return "argument"
			LocalVariable: 		return "local variable"
			Variable: 			return "variable"
			NumberLiteral: 		return "number literal"
		}	
	}
	
	// TODO: get rid of this function and use Literals.??? directly in validation methods instead
	// Returns the corresponding package literal for an EObject
	def private EStructuralFeature getStructuralFeature(EObject object) {
		switch object {
			Model:				return ZeroKnowledgePackage.Literals.MODEL__PROOF
			FunctionDefinition:	return ZeroKnowledgePackage.Literals.FUNCTION_DEFINITION__NAME
			ParameterList:		return ZeroKnowledgePackage.Literals.PARAMETER_LIST__PARAMETERS
			Parameter:			return ZeroKnowledgePackage.Literals.PARAMETER__NAME
			WitnessList:		return ZeroKnowledgePackage.Literals.WITNESS_LIST__WITNESSES
			Witness:			return ZeroKnowledgePackage.Literals.WITNESS__NAME
			Conjunction: 		return ZeroKnowledgePackage.Literals.CONJUNCTION__OPERATION
			Disjunction: 		return ZeroKnowledgePackage.Literals.DISJUNCTION__OPERATION
			Comparison: 		return ZeroKnowledgePackage.Literals.COMPARISON__OPERATION
			Sum: 				return ZeroKnowledgePackage.Literals.SUM__OPERATION
			Product: 			return ZeroKnowledgePackage.Literals.PRODUCT__OPERATION
			Power: 				return ZeroKnowledgePackage.Literals.POWER__OPERATION
			StringLiteral: 		return ZeroKnowledgePackage.Literals.STRING_LITERAL__VALUE
			Tuple: 				return ZeroKnowledgePackage.Literals.TUPLE__ELEMENTS
			Negative: 			return ZeroKnowledgePackage.Literals.NEGATIVE__OPERATION
			FunctionCall: 		return ZeroKnowledgePackage.Literals.FUNCTION_CALL__NAME
			LocalVariable: 		return ZeroKnowledgePackage.Literals.VARIABLE__NAME
			Variable: 			return ZeroKnowledgePackage.Literals.VARIABLE__NAME
			NumberLiteral: 		return ZeroKnowledgePackage.Literals.NUMBER_LITERAL__VALUE
		}
	}
}
