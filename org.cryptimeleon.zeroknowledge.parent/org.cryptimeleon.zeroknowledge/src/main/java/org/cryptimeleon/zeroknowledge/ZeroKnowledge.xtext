grammar org.cryptimeleon.zeroknowledge.ZeroKnowledge hidden(WHITESPACE, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate zeroKnowledge "http://www.cryptimeleon.org/zeroknowledge/ZeroKnowledge"

/*
 * This file specifies the syntax and grammar of the 0K language, and is written using
 * the Xtend grammar language
 * 
 * See https://www.eclipse.org/Xtext/documentation/301_grammarlanguage.html
 */

Model returns Model:
  (protocolName=PROTOCOL_NAME)? functions+=(FunctionDefinition)* witnessList=WitnessList ';'? proof=Expression ';'?;

FunctionDefinition returns FunctionDefinition:
  name=IDENTIFIER parameterList=ParameterList '{' body=Expression ';'? '}' ';'?;

ParameterList returns ParameterList:
  '(' (parameters+=Parameter (',' parameters+=Parameter)*)? symbol=')';

Parameter returns Parameter:
  name=IDENTIFIER;
  
WitnessList returns WitnessList:
  '(' (witnesses+=Witness (',' witnesses+=Witness)*)? symbol=')';

Witness returns Witness:
  name=IDENTIFIER;

Expression:
  Conjunction;

Conjunction returns Expression:
  Disjunction ({Conjunction.left=current} operation='&' right=Disjunction)*;

//ConjunctionList returns Expression:
//	protocols+=Disjunction names+=PROTOCOL_NAME (('&'|';') protocols+=Disjunction names+=PROTOCOL_NAME)*;

//Protocol returns Expression:
//  Disjunction protocol=(PROTOCOL_NAME)?;

Disjunction returns Expression:
  Comparison ({Disjunction.left=current} operation='|' right=Comparison)*;

Comparison returns Expression:
  Sum ({Comparison.left=current} operation=COMPARISON_OPERATOR center=Sum (operation2=COMPARISON_OPERATOR right=Sum)? (subprotocolName=PROTOCOL_NAME)? )?;
  
Sum returns Expression:
  Product ({Sum.left=current} operation=('+' | '-') right=Product)*;

Product returns Expression:
  Power ({Product.left=current} operation=('*' | '/') right=Power)*;
 
Power returns Expression:
	Construct ({Power.left = current} operation='^' right=Power)?;

Construct returns Expression:
  StringLiteral | Tuple | Negative;
  
StringLiteral returns StringLiteral:
  value=STRING_LITERAL;

Tuple returns Expression:
  =>({Tuple} '(' elements+=Conjunction ',') elements+=Conjunction (',' elements+=Conjunction)* ')';

Negative returns Expression:
  {Negative} operation='-' term=Value | Value;

Value returns Expression:
  FunctionCall | Variable | NumberLiteral | '(' Brackets ')';

FunctionCall returns Expression:
  {FunctionCall} (->(name=IDENTIFIER '(') (arguments+=Argument (',' arguments+=Argument)*)? ')');

Argument returns Expression:
  {Argument} expression=Conjunction;

Variable returns Variable:
  name=IDENTIFIER;

/*
 * This object will not be created during parsing, but Variable objects
 * corresponding to arguments in function definitions will be converted
 * to LocalVariable objects after parsing
 */
LocalVariable returns Variable:
  {LocalVariable} name=IDENTIFIER function=IDENTIFIER;

/*
 * This object will not be created during parsing, but Variable objects
 * corresponding to witnesses will be converted to WitnessVariable
 * objects after parsing
 */
WitnessVariable returns Variable:
  {WitnessVariable} name=IDENTIFIER;
  
/*
 * This object will not be created during parsing, but Variable objects
 * corresponding to pp-vars will be converted to PPVariable objects
 * after parsing
 */
PPVariable returns Variable:
  {PPVariable} name=IDENTIFIER;

NumberLiteral returns NumberLiteral:
  value=INT;

Brackets returns Expression:
	{Brackets} content=Expression;
	
terminal INT returns ecore::EInt:
  ('0'..'9')+;

terminal ML_COMMENT:
  '/*' -> '*/';

terminal SL_COMMENT:
  '//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WHITESPACE:
  (' '|'\t'|'\r'|'\n')+;

terminal IDENTIFIER:
	('a'..'z'|'A'..'Z') ('a'..'z'|'A'..'Z'|'0'..'9'|'_'|'\'')*;

terminal STRING_LITERAL:
 '"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"';
  
terminal COMPARISON_OPERATOR:
  '!=' | '=' | '<' | '<=' | '>' | '>=';

terminal PROTOCOL_NAME:
  ('[' ('a'..'z'|'A'..'Z') ('a'..'z'|'A'..'Z'|'0'..'9'|'_'|' ')*']');