/*
 * generated by Xtext 2.24.0
 */
package org.cryptimeleon.subzero.validation

import java.util.ArrayList
import java.util.HashSet
import java.util.Iterator
import java.util.List
import java.util.Map
import java.util.Set
import org.cryptimeleon.subzero.model.AugmentedModel
import org.cryptimeleon.subzero.model.BranchState
import org.cryptimeleon.subzero.model.FunctionSignature
import org.cryptimeleon.subzero.model.GroupType
import org.cryptimeleon.subzero.model.ModelHelper
import org.cryptimeleon.subzero.model.ModelMap
import org.cryptimeleon.subzero.model.Type
import org.cryptimeleon.subzero.predefined.PredefinedFunctionsHelper
import org.cryptimeleon.subzero.subzero.Argument
import org.cryptimeleon.subzero.subzero.Brackets
import org.cryptimeleon.subzero.subzero.Comparison
import org.cryptimeleon.subzero.subzero.Conjunction
import org.cryptimeleon.subzero.subzero.Disjunction
import org.cryptimeleon.subzero.subzero.Expression
import org.cryptimeleon.subzero.subzero.FunctionCall
import org.cryptimeleon.subzero.subzero.FunctionDefinition
import org.cryptimeleon.subzero.subzero.LocalVariable
import org.cryptimeleon.subzero.subzero.Model
import org.cryptimeleon.subzero.subzero.Negative
import org.cryptimeleon.subzero.subzero.NumberLiteral
import org.cryptimeleon.subzero.subzero.Parameter
import org.cryptimeleon.subzero.subzero.ParameterList
import org.cryptimeleon.subzero.subzero.Power
import org.cryptimeleon.subzero.subzero.Product
import org.cryptimeleon.subzero.subzero.PublicParameter
import org.cryptimeleon.subzero.subzero.PublicParameterList
import org.cryptimeleon.subzero.subzero.StringLiteral
import org.cryptimeleon.subzero.subzero.Sum
import org.cryptimeleon.subzero.subzero.Tuple
import org.cryptimeleon.subzero.subzero.Variable
import org.cryptimeleon.subzero.subzero.Witness
import org.cryptimeleon.subzero.subzero.WitnessList
import org.cryptimeleon.subzero.subzero.SubzeroPackage.Literals
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.validation.Check
import org.cryptimeleon.subzero.subzero.WitnessVariable
import java.util.HashMap
import java.util.Map.Entry
import org.cryptimeleon.subzero.model.Environment

/**
 * This class contains custom validation rules for validating the syntax tree
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 * 
 * The language grammar specification is designed to be less strict, with stricter rules
 * instead applied during validation. This allows for more descriptive errors/warnings in
 * the editor, as opposed to generating less descriptive syntax errors
 */
class SubzeroValidator extends AbstractSubzeroValidator {
	
	var Map<EObject, Type> types;
	var Map<EObject, Integer> sizes;
	var Map<String, GroupType> groupsByName;
	var Map<String, FunctionSignature> userFunctions;
	var Map<String, List<FunctionCall>> userFunctionCalls;
	var Map<String, List<WitnessVariable>> userFunctionWitnessNodes;
	var Map<String, FunctionSignature> predefinedFunctions;
	var Set<String> witnessNames;
	var Set<String> publicParameterNames;
	var Map<String, List<Variable>> variables;
	
	/*
	 * Validation proceeds in a topdown, preorder traversal of the syntax tree,
	 * starting at the root Model node.
	 * 
	 * checkModel is the only function with the @Check annotation (it will be called by the EValidator)
	 * checkNode is a dispatch function to call the corresponding validation functions for each
	 * different type of syntax tree nodes
	 * Any other function prefixed with 'check' can create validation errors or warnings
	 * All other functions are helper functions
	 */
	@Check
	def void checkModel(Model model) {
		// Do not perform validation if there are still syntax errors
		if (!model.eResource.errors.isEmpty()) {
			System.out.println("Syntax errors");
			return;
		}

		val AugmentedModel augmentedModel = new AugmentedModel(model);
		
		// Get all data needed for validation
		types = augmentedModel.getTypes();
		sizes = augmentedModel.getSizes();
		groupsByName = augmentedModel.getGroupsByName();
		userFunctions = augmentedModel.getUserFunctionSignatures();
		userFunctionCalls = augmentedModel.getUserFunctionCallNodes();
		userFunctionWitnessNodes = augmentedModel.getUserFunctionWitnessNodes();
		predefinedFunctions = PredefinedFunctionsHelper.getAllPredefinedFunctions();
		witnessNames = augmentedModel.getWitnessNames();
		publicParameterNames = augmentedModel.getPublicParameterNames();
		variables = augmentedModel.getVariableNodes();
		
		System.out.println("Validating the model");
		
		val Environment environment = new Environment(augmentedModel);
		info(environment.toString(), null, null);

		// Iterate over the tree in a preorder traversal and perform validation on each node
		ModelMap.preorderWithState(model, new BranchState(), [EObject node, BranchState state |
			checkNode(node, state);
		]);
	}
	
	def dispatch void checkNode(Model model, BranchState state) {
		checkFunctionNamesAreUnique(model);
		checkSubprotocolNamesAreUnique(model);
		checkOrWithAndAncestorGroupElementWitnesses(model);
		checkHasProof(model);
	}
	
	def dispatch void checkNode(FunctionDefinition function, BranchState state) {
		checkFunctionNameFormat(function);
		checkFunctionNameIsNotPredefined(function);
		checkFunctionIsCalled(function);
		checkFunctionParametersAreUsed(function);
		checkFunctionHasNoDisjunction(function);
	}

	def dispatch void checkNode(ParameterList parameterList, BranchState state) {
		checkFunctionParameterNamesAreUnique(parameterList);
	}
	
	def dispatch void checkNode(Parameter parameter, BranchState state) {
		checkParameterNameFormat(parameter);
	}
	
	def dispatch void checkNode(PublicParameterList publicParameterList, BranchState state) {
		checkPublicParameterNamesAreUnique(publicParameterList);
	}
	
	def dispatch void checkNode(PublicParameter publicParameter, BranchState state) {
		checkPublicParameterNameFormat(publicParameter);
		checkPublicParameterIsUsed(publicParameter);
	}
	
	def dispatch void checkNode(WitnessList witnessList, BranchState state) {
		checkWitnessListIsNonempty(witnessList);
		checkWitnessNamesAreUnique(witnessList);
	}
	
	def dispatch void checkNode(Witness witness, BranchState state) {
		checkWitnessNameFormat(witness);
		checkWitnessIsUsed(witness);
	}
	
	def dispatch void checkNode(Conjunction conjunction, BranchState state) {
		checkConjunctionPositionIsValid(conjunction, state);
		checkIsBoolean(conjunction);
		checkConjunctionOperands(conjunction);
		checkIsScalar(conjunction);
	}
	
	def dispatch void checkNode(Disjunction disjunction, BranchState state) {
		checkDisjunctionPositionIsValid(disjunction, state);
		checkIsBoolean(disjunction);
		checkDisjunctionOperands(disjunction);
		checkIsScalar(disjunction);
	}
	
	def dispatch void checkNode(Comparison comparison, BranchState state) {
		checkComparisonOperations(comparison);
		checkValidComparisonPosition(comparison, state);
		checkIsBoolean(comparison);
		checkComparisonOperands(comparison);
		checkIsScalar(comparison);
	}
	
	def dispatch void checkNode(Sum sum, BranchState state) {
		checkProofAlgebraicPosition(sum, state);
		checkValidAlgebraicPosition(sum, state);
		checkIsExponent(sum);
		checkSumOperands(sum);
	}
	
	def dispatch void checkNode(Product product, BranchState state) {
		checkProofAlgebraicPosition(product, state);
		checkValidAlgebraicPosition(product, state);
		checkProductOperands(product);
	}
	
	def dispatch void checkNode(Power power, BranchState state) {
		checkWitnessIsNotInExponentOfWitness(power);
		checkProofAlgebraicPosition(power, state);
		checkValidAlgebraicPosition(power, state);
		checkIsExponent(power.getRight());
		checkPowerOperands(power);
	}
	
	def dispatch void checkNode(StringLiteral stringLiteral, BranchState state) {
		checkStringLiteralPositionIsValid(stringLiteral, state);
		checkIsString(stringLiteral);
		checkIsScalar(stringLiteral);
	}
	
	def dispatch void checkNode(Tuple tuple, BranchState state) {
		checkProofAlgebraicPosition(tuple, state);
		checkTupleElementsAreSameType(tuple);
		checkTuplePositionIsValid(tuple, state);
		checkTupleSize(tuple);
		checkIsTuple(tuple);
	}
	
	def dispatch void checkNode(Negative negative, BranchState state) {
		checkProofAlgebraicPosition(negative, state);
		checkIsExponent(negative);
	}
	
	def dispatch void checkNode(FunctionCall call, BranchState state) {
		checkFunctionCallIsValid(call);
		checkFunctionHasNoFunctionCalls(call, state);
		checkFunctionCallPositionIsValid(call, state);
		checkPredefinedFunctionCallType(call);
	}
	
	def dispatch void checkNode(Argument argument, BranchState state) {
	}
	
	def dispatch void checkNode(Variable variable, BranchState state) {
		checkVariableNameFormat(variable);
		checkProofAlgebraicPosition(variable, state);
		checkGroupType(variable);
	}
	
	def dispatch void checkNode(NumberLiteral numberLiteral, BranchState state) {
		checkProofAlgebraicPosition(numberLiteral, state);
		checkIsExponent(numberLiteral);
		checkIsScalar(numberLiteral);
	}
	
	def dispatch void checkNode(Brackets brackets, BranchState state) {
		checkProofAlgebraicPosition(brackets, state);
	}
	
	def dispatch void checkNode(EObject node, BranchState state) {
		System.err.println("Error: unhandled node type in validator");
	}
	
	/*
	 * Validate the format of identifier names
	 */
	 
	// User defined function names must start with a letter, and contain only letters and numbers
	def private void checkFunctionNameFormat(FunctionDefinition function) {
		if (function.getName().contains("_")) {
			error("Function names cannot contain underscores", function,
				getDefaultFeature(function));
		}
		if (function.getName().contains("'")) {
			error("Function names cannot contain single quotes", function,
				getDefaultFeature(function));
		}
	}
	
	// Public parameter names must start with a letter, and only contain letters, numbers, at most 1 underscore
	// (to denote subscript) and any number of single quotes at the end
	def private void checkPublicParameterNameFormat(PublicParameter publicParameter) {
		var List<String> errors = nameFormatErrors(publicParameter.getName(), "Public parameter");
		for (String errorMessage : errors) {
			error(errorMessage, publicParameter, getDefaultFeature(publicParameter));
		}
	}

	// Witness names must start with a letter, and only contain letters, numbers, at most 1 underscore
	// (to denote subscript) and any number of single quotes at the end
	def private void checkWitnessNameFormat(Witness witness) {
		var List<String> errors = nameFormatErrors(witness.getName(), "Witness");
		for (String errorMessage : errors) {
			error(errorMessage, witness, getDefaultFeature(witness));
		}
	}

	// Variable names must start with a letter, and only contain letters, numbers, at most 1 underscore
	// (to denote subscript) and any number of single quotes at the end
	def private void checkVariableNameFormat(Variable variable) {
		var List<String> errors = nameFormatErrors(variable.getName(), "Variable");
		for (String errorMessage : errors) {
			error(errorMessage, variable, getDefaultFeature(variable));
		}
	}

	// Parameter names must start with a letter, and only contain letters, numbers, at most 1 underscore
	// (to denote subscript) and any number of single quotes at the end
	def private void checkParameterNameFormat(Parameter parameter) {
		var List<String> errors = nameFormatErrors(parameter.getName(), "Parameter");
		for (String errorMessage : errors) {
			error(errorMessage, parameter, getDefaultFeature(parameter));
		}
	}

	// Helper function for checking the name format of identifiers
	def private List<String> nameFormatErrors(String identifier, String type) {
		var List<String> nameErrors = new ArrayList<String>();

		val char underscore = '_';
		var int underscores = 0;
		for (var int i = 0; i < identifier.length(); i++) {
			if (identifier.charAt(i) == underscore) {
				underscores++;
				if (underscores > 1) {
					nameErrors.add(type + " name can contain at most 1 underscore");
					i = identifier.length();
				}
			}
		}

		val char quote = '\'';
		var boolean hasQuote = false;
		for (var int i = 0; i < identifier.length(); i++) {
			if (hasQuote && identifier.charAt(i) != quote) {
				nameErrors.add(type + " name can only contain single quotes at the end of the name");
				i = identifier.length();
			} else if (identifier.charAt(i) == quote) {
				hasQuote = true;
			}
		}

		if (identifier.charAt(identifier.length() - 1) == underscore) {
			nameErrors.add(type + " name cannot end with an underscore");
		}

		return nameErrors;
	}

	/*
	 * Validate the uniqueness of identifiers
	 */
	 
	// User defined function names must be unique
	def private void checkFunctionNamesAreUnique(Model model) {
		val Set<String> functions = new HashSet<String>();
		for (FunctionDefinition function : model.getFunctions()) {
			val String name = function.getName();
			if (functions.contains(name)) {
				error("Function names must be unique", function, getDefaultFeature(function));
			} else {
				functions.add(name);
			}
		}
	}
	
	// Subprotocol names must be unique
	def private void checkSubprotocolNamesAreUnique(Model model) {
		val Set<String> subprotocolNames = new HashSet<String>();
		ModelMap.preorder(model.getProof(), [EObject node |
			if (node instanceof Comparison) {
				val String subprotocolName = node.getSubprotocolName();
				if (subprotocolNames.contains(subprotocolName)) {
					error("Subprotocol names must be unique", node, getDefaultFeature(node));
				} else if (subprotocolName !== null && !subprotocolName.isEmpty()) {
					subprotocolNames.add(subprotocolName);
				}
			}
		]);
	}

	// User defined functions cannot have the same name as a predefined function
	def private void checkFunctionNameIsNotPredefined(FunctionDefinition function) {
		if (predefinedFunctions.containsKey(function.getName())) {
			error("Function name is already used by a predefined function", function, getDefaultFeature(function));
		}
	}
	
	// Public parameter names must be unique
	def private void checkPublicParameterNamesAreUnique(PublicParameterList publicParameterList) {
		val HashSet<String> publicParameters = new HashSet<String>();
		for (PublicParameter publicParameter : publicParameterList.getPublicParameters()) {
			val String name = publicParameter.getName();
			if (publicParameters.contains(name)) {
				error("Public parameter names must be unique", publicParameter, getDefaultFeature(publicParameter));
			} else if (witnessNames.contains(name)) {
				error("Public parameter name conflicts with a witness name", publicParameter, getDefaultFeature(publicParameter));
			} else {
				publicParameters.add(name);				
			}
		}
	}

	// Witness names must be unique
	def private void checkWitnessNamesAreUnique(WitnessList witnessList) {
		val HashSet<String> witnesses = new HashSet<String>();
		for (Witness witness : witnessList.getWitnesses()) {
			val String name = witness.getName();
			if (witnesses.contains(name)) {
				error("Witness names must be unique", witness, getDefaultFeature(witness));
			} else if (publicParameterNames.contains(name)) {
				error("Witness name conflicts with a public parameter name", witness, getDefaultFeature(witness));
			} else {
				witnesses.add(name);				
			}
		}
	}

	// Function parameter names must be unique within a function signature
	def private void checkFunctionParameterNamesAreUnique(ParameterList parameterList) {
		val HashSet<String> parameters = new HashSet<String>();
		for (Parameter parameter : parameterList.getParameters()) {
			val String name = parameter.getName();
			if (parameters.contains(name)) {
				error("Function parameters must be unique within a function's signature", parameter, getDefaultFeature(parameter));
			} else {
				parameters.add(name);
			}
		}
	}

	/*
	 * Validate user function definitions
	 */
	 
	// Function definitions cannot contain function calls to other user functions
	def private void checkFunctionHasNoFunctionCalls(FunctionCall call, BranchState state) {
		if (state.hasFunctionDefinitionAncestor()) {
			error("Cannot call functions from within a user function", call, getDefaultFeature(call));
		}
	}

	// Every function parameter should be used at least once in the function definition
	def private void checkFunctionParametersAreUsed(FunctionDefinition function) {
		val HashSet<String> functionVariables = new HashSet<String>();
		
		ModelMap.postorder(function.getBody(), [EObject node |
			if (node instanceof LocalVariable) {
				functionVariables.add(node.getName());
			}
		])
		
		for (Parameter parameter: function.getParameterList().getParameters()) {
			if (!functionVariables.contains(parameter.getName())) {
				warning('''Parameter '«parameter.getName()»' should be used within the function definition''', parameter, getDefaultFeature(parameter));
			}
		}
	}

	// User defined functions should be called at least once in the proof expression
	def private void checkFunctionIsCalled(FunctionDefinition function) {
		val String functionName = function.getName();
		
		if (!userFunctionCalls.containsKey(functionName)) {
			warning(
				"Function is never used in the proof expression, and will not be included in the generated Java code", function,
				getDefaultFeature(function));
		}
	}
	
	// User defined functions cannot currently contain a disjunction
	def private void checkFunctionHasNoDisjunction(FunctionDefinition function) {
		val boolean hasDisjunction = ModelMap.postorderAny(function.getBody(), [EObject node |
			return node instanceof Disjunction;
		]);
		
		if (hasDisjunction) {
			error("Disjunctions are currently not supported in user functions", function, getDefaultFeature(function));
		}
	}
	
	/*
	 * Validate the proof expression
	 */
	def private void checkHasProof(Model model) {
		if (model.getProof() === null) {
			error("Must have a proof statement", model, getDefaultFeature(model));
		}
	}

	/*
	 * Validate the witness list
	 */
	 
	// The witness list must contain at least one witness
	def private void checkWitnessListIsNonempty(WitnessList witnessList) {
		if (witnessList.getWitnesses().size() === 0) {
			error("The witness list must include at least one witness", witnessList,
				getDefaultFeature(witnessList));
		}
	}
	
	// Each witness should be referenced at least once
	def private void checkWitnessIsUsed(Witness witness) {
		val name = witness.getName();
		if (!variables.containsKey(name)) {
			warning('''The witness '«name»' is not used in the proof expression or any function definition''', witness, getDefaultFeature(witness));
		}
	}
	
	/*
	 * Validate the public parameter list
	 */
	
	// Each witness should be referenced at least once
	def private void checkPublicParameterIsUsed(PublicParameter publicParameter) {
		val name = publicParameter.getName();
		if (!variables.containsKey(name)) {
			warning('''The public parameter '«name»' is not used in the proof expression or any function definition''', publicParameter, getDefaultFeature(publicParameter));
		}
	}

	/*
	 * Validate function calls
	 */
	 
	// Function calls must reference either a user defined function or a predefined function
	// The number of arguments in a function call must match the number of parameters in the function definition
	def private void checkFunctionCallIsValid(FunctionCall call) {
		val String name = call.getName();

		if (userFunctions.containsKey(name)) {
			val FunctionSignature signature = userFunctions.get(name);
			functionCallIsValidHelper(call, signature);
			return;
		}

		if (predefinedFunctions.containsKey(name)) {
			val FunctionSignature signature = predefinedFunctions.get(name);
			functionCallIsValidHelper(call, signature);
			return;
		}
		
		error("Function call references a function that does not exist", call,
			getDefaultFeature(call));
	}
	
	def private void functionCallIsValidHelper(FunctionCall call, FunctionSignature signature) {
		if (signature.getParameterCount() !== call.getArguments().size()) {
			error(
				'''The number of arguments in the function call («call.getArguments().size()») must match the number of parameters in the function definition («signature.getParameterCount()»)''', call,
				getDefaultFeature(call));
			return;
		}
		
		val Iterator<Type> parameterTypesIterator = signature.getParameterTypes.iterator();
		val Iterator<Integer> parameterSizesIterator = signature.getParameterSizes.iterator();
		val Iterator<Expression> argumentsIterator = call.getArguments().iterator();
		
		while (parameterTypesIterator.hasNext() && parameterSizesIterator.hasNext() && argumentsIterator.hasNext()) {
			val Type parameterType = parameterTypesIterator.next();
			val int parameterSize = parameterSizesIterator.next();
			val EObject argument = argumentsIterator.next();
			
			if (types.get(argument) !== parameterType) {
				error('''The argument type («types.get(argument)») does not match the function parameter type («parameterType»)''', argument, getDefaultFeature(argument));
			}
			
			if (sizes.get(argument) !== parameterSize) {
				error('''The argument size («sizes.get(argument)») does not match the function parameter size («parameterSize»)''', argument, getDefaultFeature(argument));
			}
		}
	}
	
	/*
	 * Validate grammar structure
	 */
	
	// String literals must be directly nested within a tuple, a comparison, or a function call
	def private void checkStringLiteralPositionIsValid(StringLiteral stringLiteral, BranchState state) {
		val EObject parent = state.getParent();
		
		if (!(parent instanceof FunctionCall)) {
			error("String literals can only be used as arguments in calls to predefined functions", stringLiteral, getDefaultFeature(stringLiteral));
		}
		
	}

	// Conjunctions cannot be nested within algebraic expressions or comparison expressions
	def private void checkConjunctionPositionIsValid(Conjunction conjunction, BranchState state) {
		if (!isValidBooleanPosition(conjunction, state)) {
			error("Conjunctions cannot be nested within algebraic expressions, comparison expressions, or function calls", conjunction,
				getDefaultFeature(conjunction));
		}
	}

	// Disjunctions cannot be nested within algebraic expressions or comparison expressions
	def private void checkDisjunctionPositionIsValid(Disjunction disjunction, BranchState state) {
		if (!isValidBooleanPosition(disjunction, state)) {
			error("Disjunctions cannot be nested within algebraic expressions, comparison expressions, or function calls", disjunction,
				getDefaultFeature(disjunction));
		}
	}

	// Comparisons cannot be nested within algebraic expressions or comparison expressions
	def private void checkValidComparisonPosition(Comparison comparison, BranchState state) {
		if (!isValidBooleanPosition(comparison, state)) {
			error("Comparisons cannot be nested within algebraic expressions, other comparison expressions, or function calls", comparison,
				getDefaultFeature(comparison));
		}
	}
	
	// Double comparisons cannot use equals or not equals, and inequality operators must be the same direction
	def private void checkComparisonOperations(Comparison comparison) {
		val String operation1 = comparison.getOperation();
		val String operation2 = comparison.getOperation2();
		
		// Check if the comparison is not equals (not yet supported)
		if (operation1 == "!=") {
			error("The != operator is currently not supported", comparison, getDefaultFeature(comparison));
		}
		
		// Check if the comparison is a double comparison
		if (operation2 !== null) {
			
			if (operation1 == "=" || operation1 == "!=" || operation2 == "=" || operation2 == "!=") {
				error("Cannot use = or != in a double comparison", comparison, getDefaultFeature(comparison));
			} else if (operation1.charAt(0) != operation2.charAt(0)) {
				error("Comparison operators in a double comparison must be in the same direction", comparison, getDefaultFeature(comparison));
			}
		}
	}
	
	// Helper function for checkValidConjunctionPosition, checkValidDisjunctionPosition, and checkValidComparisonPosition
	def private boolean isValidBooleanPosition(EObject node, BranchState state) {
		val EObject parent = state.getParent();
		if (parent instanceof Model || parent instanceof FunctionDefinition || parent instanceof Conjunction || parent instanceof Disjunction) {
			return true;
		}
		return false;
	}

	// Algebraic expressions must be nested within a comparison expression before being nested within a propositional expression
	def private void checkValidAlgebraicPosition(EObject node, BranchState state) {
		if (state.hasFunctionDefinitionAncestor() || state.hasFunctionCallAncestor()) return;

		if (state.hasPropositionalBeforeComparison()) {
			error("Algebraic expression must be nested within a comparison expression before being nested within a propositional expression", node, getDefaultFeature(node))
		}
	}

	// Algebraic expressions in the proof expression must be nested within a comparison expression or function call
	def private void checkProofAlgebraicPosition(EObject object, BranchState state) {
		if (state.hasFunctionDefinitionAncestor()) return;
		
		if (!(state.hasComparisonAncestor() || state.hasFunctionCallAncestor())) {
			error("Algebraic expressions in the proof expression must be nested within a comparison expression or function call", object, getDefaultFeature(object));
		}
	}
	
	// Function calls to boolean functions cannot be nested within algebraic expressions, comparison expressions, or other function calls
	def private void checkFunctionCallPositionIsValid(FunctionCall call, BranchState state) {
		if (types.get(call) === Type.BOOLEAN) {
			if (!isValidBooleanPosition(call, state)) {
				error("Function calls to boolean functions cannot be nested within algebraic expressions, comparison expressions, or other function calls", call, getDefaultFeature(call));
			};
		} else {			
			checkProofAlgebraicPosition(call, state);
		}
	}
	
	def private void checkPredefinedFunctionCallType(FunctionCall call) {
		if (predefinedFunctions.containsKey(call.getName())) {
			val Type currentType = types.get(call);
			val Type correctType = predefinedFunctions.get(call.getName()).getReturnType();
			
			if (currentType !== correctType) {
				error('''Predefined function call should have type «correctType», not type «currentType»''', call, getDefaultFeature(call));
			}
		}
	}
	
	def private void checkWitnessIsNotInExponentOfWitness(Power power) {
		val EObject left = power.getLeft();
		val EObject right = power.getRight();
		
		if (left instanceof WitnessVariable) {
			ModelMap.preorder(right, [EObject node |
				if (node instanceof WitnessVariable) {
					createWitnessIsNotInExponentOfWitnessError(node);
				} else if (node instanceof FunctionCall) {
					val String functionName = node.getName();
					if (userFunctionWitnessNodes.containsKey(functionName)) {
						val List<WitnessVariable> witnessNodes = userFunctionWitnessNodes.get(functionName);
						for (WitnessVariable witnessNode : witnessNodes) {
							createWitnessIsNotInExponentOfWitnessError(witnessNode);
						}
					}
				}
			]);
		}
	}
	
	def private void createWitnessIsNotInExponentOfWitnessError(WitnessVariable witness) {
		error("A witness cannot be in the exponent of another witness", witness, getDefaultFeature(witness));
	}
	
	
	/*
	 * Validate that the operands of a binary operation are of compatible type
	 */
	 
	def private void checkConjunctionOperands(Conjunction conjunction) {
		val Type leftType = types.get(conjunction.getLeft());
		val Type rightType = types.get(conjunction.getRight());
		
		if (types.get(conjunction.getLeft()) !== Type.BOOLEAN || types.get(conjunction.getRight()) !== Type.BOOLEAN) {
			error('''Conjunction operands must both have type boolean. The left operand is of type «leftType» and the right operand is of type «rightType»''', conjunction, getDefaultFeature(conjunction));
		}
	} 
	
	def private void checkDisjunctionOperands(Disjunction disjunction) {
		val Type leftType = types.get(disjunction.getLeft());
		val Type rightType = types.get(disjunction.getRight());
		
		if (types.get(disjunction.getLeft()) !== Type.BOOLEAN || types.get(disjunction.getRight()) !== Type.BOOLEAN) {
			error('''Disjunction operands must both have type boolean. The left operand is of type «leftType» and the right operand is of type «rightType»''', disjunction, getDefaultFeature(disjunction));
		}
	}
	
	def private void checkComparisonOperands(Comparison comparison) {
		val EObject left = comparison.getLeft();
		val EObject right = comparison.getRight();
		val Type leftType = types.get(left);
		val Type rightType = types.get(right);
		val int leftSize = sizes.get(left);
		val int rightSize = sizes.get(right);
		
		val boolean leftHasWitness = ModelHelper.containsWitnessVariable(left);
		val boolean rightHasWitness = ModelHelper.containsWitnessVariable(right);
		
		if (comparison.getOperation2() === null) {
			if (leftType !== rightType) {
				error('''The operands of a comparison node must be the same type. The left operand is of type «leftType» but the right operand is of type «rightType»''', comparison, getDefaultFeature(comparison));
			}
			
			if (leftSize !== rightSize) {
				error('''The operands of a comparison node must be the same size. The left operand is of size «leftSize» but the right operand is of size «rightSize»''', comparison, getDefaultFeature(comparison));
			}
			
			if (ModelHelper.isInequalityComparison(comparison)) {
				if (!leftHasWitness && !rightHasWitness) {
					error("One side of a comparison must be dependent on a witness variable", comparison, getDefaultFeature(comparison));
				}
				
				if (leftHasWitness && rightHasWitness) {
					error("Only one side of a comparison can be dependent on a witness variable", comparison, getDefaultFeature(comparison));
				}
			}
				
		} else {
			val EObject center = comparison.getCenter();
			val Type centerType = types.get(center);
			val int centerSize = sizes.get(center);
			
			val boolean centerHasWitness = ModelHelper.containsWitnessVariable(center);
			
			if (leftType !== centerType || centerType !== rightType) {
				error('''The operands of a comparison node must be the same type. The left operand is of type «leftType», the middle operand is of type «centerType», and the right operand is of type«rightType»''', comparison, getDefaultFeature(comparison));
			}
			
			if (leftSize !== centerSize || centerSize !== rightSize) {
				error('''The operands of a comparison node must be the same size. The left operand is of size «leftSize», the middle operand is of size «centerSize», and the right operand is of size«rightSize»''', comparison, getDefaultFeature(comparison));
			}
			
			if (!centerHasWitness) {
				error("The middle of a double comparison must be dependent on a witness variable", comparison, getDefaultFeature(comparison));
			}
			
			if (leftHasWitness || rightHasWitness) {
				error("Only the middle of a double comparison can be dependent on a witness variable", comparison, getDefaultFeature(comparison));
			}
		}
		
	}
	
	def private void checkSumOperands(Sum sum) {
		val Type leftType = types.get(sum.getLeft());
		val Type rightType = types.get(sum.getRight());
		val int leftSize = sizes.get(sum.getLeft());
		val int rightSize = sizes.get(sum.getRight());
		
		if (leftType !== Type.EXPONENT || rightType !== Type.EXPONENT) {
			error('''Sum operands must both have type exponent. The left operand is of type «leftType» and the right operand is of type «rightType»''', sum, getDefaultFeature(sum));
		}
		
		if (leftSize !== rightSize) {
			error('''The operands of a sum node must be the same size. The left operand is of size «leftSize» but the right operand is of size «rightSize»''', sum, getDefaultFeature(sum));
		}
	}
	
	def private void checkProductOperands(Product product) {
		val Type leftType = types.get(product.getLeft());
		val Type rightType = types.get(product.getRight());
		val int leftSize = sizes.get(product.getLeft());
		val int rightSize = sizes.get(product.getRight());
		
		if (leftType !== rightType) {
			error('''The operands of a product node must be the same type. The left operand is of type «leftType» but the right operand is of type «rightType»''', product, getDefaultFeature(product));
		}
		
		if (leftType === Type.GROUP_ELEMENT && rightType === Type.GROUP_ELEMENT && leftSize !== rightSize) {
			error('''The operands of a group element product node must be the same size. The left operand is of size «leftSize» but the right operand is of size «rightSize»''', product, getDefaultFeature(product));
		}		
	}
	
	def private void checkPowerOperands(Power power) {
		val Type type = types.get(power);
		val Type leftType = types.get(power.getLeft());
		val Type rightType = types.get(power.getRight());
		val int rightTuple = sizes.get(power.getRight());

		if (!(leftType === Type.EXPONENT || leftType === Type.GROUP_ELEMENT)) {
			error('''The left operand of a power node must be of type exponent or group element, not type «leftType»''', power, getDefaultFeature(power));
		}
		
		if (rightType !== Type.EXPONENT) {
			error('''The right operand of a power node must be of type exponent, not type «rightType»''', power, getDefaultFeature(power));
		}
		
		if (type !== leftType) {
			error('''The type of a power node must be the same as the type of the left operand. The power node is of type «type» but the left operand is of type «leftType»''', power, getDefaultFeature(power));
		}
		
		if (rightTuple > 1) {
			error('''The right operand of a power node cannot be a tuple''', power, getDefaultFeature(power));
		}
	}
	
	def private void checkTupleElementsAreSameType(Tuple tuple) {
		val Type tupleType = types.get(tuple);
		
		for (EObject element : tuple.getElements()) {
			val Type elementType = types.get(element);
			
			if (tupleType !== elementType) {
				error('''Tuple elements must be the same type as the tuple. The tuple has type «tupleType», but the element has type «elementType»''', element, getDefaultFeature(element));
			}
		}
	}
	
	// A group element witness cannot be in both subtrees of a disjunction
	// that has a conjunction ancestor
	def private void checkOrWithAndAncestorGroupElementWitnesses(Model model) {
		ModelMap.preorderWithStateAndControl(model.getProof(), new BranchState(), [EObject node, BranchState state, ModelMap.Controller controller |
			if (node instanceof Disjunction && state.hasConjunctionAncestor()) {
				controller.continueTraversal();
				
				val Map<String, List<WitnessVariable>> witnessNodes = new HashMap<String, List<WitnessVariable>>();
				orTreeHelper(node, witnessNodes);
			}
		]);
	}
	
	def private void orTreeHelper(EObject node, Map<String, List<WitnessVariable>> witnessNodes) {
		if (node instanceof WitnessVariable) {
			orTreeWitnessNodeHelper(node, witnessNodes);
			
		} else if (node instanceof FunctionCall) {
			val String functionName = node.getName();
			if (userFunctionWitnessNodes.containsKey(functionName)) {
				val List<WitnessVariable> functionWitnessNodes = userFunctionWitnessNodes.get(functionName);
				for (WitnessVariable witnessNode : functionWitnessNodes) {
					orTreeWitnessNodeHelper(witnessNode, witnessNodes);
				}
			}
			for (Expression argument : node.getArguments()) {
				orTreeHelper(argument, witnessNodes);
			}
			
		} else if (node instanceof Disjunction) {
			var Map<String, List<WitnessVariable>> leftWitnessNodes = new HashMap<String, List<WitnessVariable>>();
			var Map<String, List<WitnessVariable>> rightWitnessNodes = new HashMap<String, List<WitnessVariable>>();
			orTreeHelper(node.getLeft(), leftWitnessNodes);
			orTreeHelper(node.getRight(), rightWitnessNodes);
			
			val Set<String> sharedNames = new HashSet<String>(leftWitnessNodes.keySet());
			sharedNames.retainAll(rightWitnessNodes.keySet());
			
			for (String name : sharedNames) {
				createOrErrors(leftWitnessNodes.get(name));
				createOrErrors(rightWitnessNodes.get(name));
			}
			
			mergeMapsOfLists(witnessNodes, leftWitnessNodes);
			mergeMapsOfLists(witnessNodes, rightWitnessNodes);
			
		} else {
			for (EObject child : node.eContents()) {
				orTreeHelper(child, witnessNodes);
			}
		}
	}
	
	def private void orTreeWitnessNodeHelper(WitnessVariable witness, Map<String, List<WitnessVariable>> witnessNodes) {
		if (types.get(witness) === Type.GROUP_ELEMENT) {
			val String name = witness.getName();
			
			if (witnessNodes.containsKey(name)) {
				witnessNodes.get(name).add(witness);
			} else {
				val List<WitnessVariable> variables = new ArrayList<WitnessVariable>();
				variables.add(witness);
				witnessNodes.put(name, variables);
			}
		}
	}
	
	def private void createOrErrors(List<WitnessVariable> witnessVariables) {
		for (WitnessVariable variable : witnessVariables) {
			error(
				"A group element witness cannot be in both operands of a disjunction that is within a conjunction",
				variable,
				getDefaultFeature(variable)
			);
		}
	}
	
	/*
	 * Validate that nodes with a predetermined type are actually this type
	 */	
	 
	def private void checkIsBoolean(EObject node) {
		checkIsType(node, Type.BOOLEAN);
	}
	
	def private void checkIsExponent(EObject node) {
		checkIsType(node, Type.EXPONENT);
	}
	
	def private void checkIsGroupElement(EObject node) {
		checkIsType(node, Type.GROUP_ELEMENT);
	}
	
	def private void checkIsExponentOrGroupElement(EObject node) {
		if (!types.containsKey(node)) {
			error('''«capitalize(getNodeName(node))» must be of type exponent or group element''', node, getDefaultFeature(node));
		} else {
			error('''«capitalize(getNodeName(node))» must be of type exponent or group element, not type «types.get(node)»''', node, getDefaultFeature(node));
		}
	}
	
	def private void checkIsString(EObject node) {
		checkIsType(node, Type.STRING);
	}
	
	def private void checkIsType(EObject node, Type type) {
		if (!types.containsKey(node)) {
			error('''«capitalize(getNodeName(node))» must be of type «type»''', node, getDefaultFeature(node));
		} else if (types.get(node) !== type) {
			error('''«capitalize(getNodeName(node))» must be of type «type», not type «types.get(node)»''', node, getDefaultFeature(node));
		}
	}
	
	def private void checkIsScalar(EObject node) {
		if (!sizes.containsKey(node)) {
			error('''«capitalize(getNodeName(node))» must be a scalar''', node, getDefaultFeature(node));	
		} else if (sizes.get(node) !== 1) {
			error('''«capitalize(getNodeName(node))» must be a scalar, not a tuple of size «sizes.get(node)»''', node, getDefaultFeature(node));
		}
	}
	
	def private void checkIsTuple(EObject node) {
		if (!sizes.containsKey(node)) {
			error('''«capitalize(getNodeName(node))» must be a tuple''', node, getDefaultFeature(node));		
		} else if (sizes.get(node) <= 1) {
			error('''«capitalize(getNodeName(node))» must be a tuple, not a scalar''', node, getDefaultFeature(node));
		}
	}
	
	/*
	 * Validate tuples
	 */
	
	// Tuples must be nested within a function call before being nested within another tuple
	def private void checkTuplePositionIsValid(Tuple tuple, BranchState state) {
		if (state.hasTupleBeforeFunctionCall()) {
			error('''Tuples must be nested within a function call before being nested within another tuple''', tuple, getDefaultFeature(tuple));
		}
	}
	
	def private void checkTupleSize(Tuple tuple) {
		val int currentSize = sizes.get(tuple);
		val int correctSize = tuple.getElements().size();
		
		if (currentSize !== correctSize) {
			error('''The operands of operations between tuples must have the same size. This tuple of size «correctSize» is in an operation with a tuple of size «currentSize»''', tuple ,getDefaultFeature(tuple));
		}
	}
	
	/*
	 * Validate group types
	 * 
	 */
	 def private void checkGroupType(Variable variable) {
	 	if (groupsByName.get(variable.getName()) === GroupType.UNKNOWN) {
	 		error("Variable is used in conflicting group element contexts", variable, getDefaultFeature(variable));
	 	}
	 }
	 
	
	/*
	 * Additional helper functions
	 */	
	
	// Capitalizes the first letter of the string
	def private String capitalize(String string) {
		if (string.isEmpty()) return "";
		return string.substring(0, 1).toUpperCase() + string.substring(1);
	}
	
	// Merges two maps of lists into the first map of lists
	def private <K, T> void mergeMapsOfLists(Map<K, List<T>> finalMap, Map<K, List<T>> mergedMap) {
		for (Entry<K, List<T>> entry : mergedMap.entrySet()) {
			val K name = entry.getKey();
			val List<T> list = entry.getValue();
			
			if (finalMap.containsKey(name)) {
				finalMap.get(name).addAll(list);
			} else {
				finalMap.put(name, list);
			}
		}
	}
	
	// Returns the name of the type of node
	def private String getNodeName(EObject node) {
		val String className = node.class.getSimpleName();
		var String nodeName = "";
		nodeName += Character.toLowerCase(className.charAt(0));
		
		for (var int i = 0; i < className.length(); i++) {
			val char letter = className.charAt(i);
			if (Character.isUpperCase(letter)) {
				nodeName += " " + Character.toLowerCase(letter);
			} else {
				nodeName += letter;
			}
		}
	
		return nodeName;		
	}
	
	// Returns the default structural feature for a node
	def private EStructuralFeature getDefaultFeature(EObject object) {
		switch object {
			Model:				return Literals.MODEL__PROOF
			FunctionDefinition:	return Literals.FUNCTION_DEFINITION__NAME
			ParameterList:		return Literals.PARAMETER_LIST__PARAMETERS
			Parameter:			return Literals.PARAMETER__NAME
			WitnessList:		return Literals.WITNESS_LIST__WITNESSES
			Witness:			return Literals.WITNESS__NAME
			PublicParameterList:return Literals.PUBLIC_PARAMETER_LIST__PUBLIC_PARAMETERS
			PublicParameter:    return Literals.PUBLIC_PARAMETER__NAME
			Conjunction: 		return Literals.CONJUNCTION__OPERATION
			Disjunction: 		return Literals.DISJUNCTION__OPERATION
			Comparison: 		return Literals.COMPARISON__OPERATION
			Sum: 				return Literals.SUM__OPERATION
			Product: 			return Literals.PRODUCT__OPERATION
			Power: 				return Literals.POWER__OPERATION
			StringLiteral: 		return Literals.STRING_LITERAL__VALUE
			Tuple: 				return Literals.TUPLE__ELEMENTS
			Negative: 			return Literals.NEGATIVE__OPERATION
			FunctionCall: 		return Literals.FUNCTION_CALL__NAME
			LocalVariable: 		return Literals.VARIABLE__NAME
			Variable: 			return Literals.VARIABLE__NAME
			NumberLiteral: 		return Literals.NUMBER_LITERAL__VALUE
		}
	}
}
