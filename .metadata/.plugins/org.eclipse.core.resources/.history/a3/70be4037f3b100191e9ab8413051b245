/*
 * generated by Xtext 2.17.0
 */
package de.upb.crypto.zeroknowledge.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import java.util.ArrayList
import java.util.Map
import java.util.HashMap
import java.util.Set
import java.util.HashSet

import de.upb.crypto.zeroknowledge.helpers.BranchState
import de.upb.crypto.zeroknowledge.zeroKnowledge.Model
import de.upb.crypto.zeroknowledge.zeroKnowledge.Conjunction
import de.upb.crypto.zeroknowledge.zeroKnowledge.Disjunction
import de.upb.crypto.zeroknowledge.zeroKnowledge.Comparison
import de.upb.crypto.zeroknowledge.zeroKnowledge.Sum
import de.upb.crypto.zeroknowledge.zeroKnowledge.Product
import de.upb.crypto.zeroknowledge.zeroKnowledge.Power
import de.upb.crypto.zeroknowledge.zeroKnowledge.StringLiteral
import de.upb.crypto.zeroknowledge.zeroKnowledge.Tuple
import de.upb.crypto.zeroknowledge.zeroKnowledge.Negative
import de.upb.crypto.zeroknowledge.zeroKnowledge.FunctionCall
import de.upb.crypto.zeroknowledge.zeroKnowledge.Variable
import de.upb.crypto.zeroknowledge.zeroKnowledge.NumberLiteral
import de.upb.crypto.zeroknowledge.zeroKnowledge.Brackets
import de.upb.crypto.zeroknowledge.zeroKnowledge.FunctionDefinition
import de.upb.crypto.zeroknowledge.zeroKnowledge.Parameter
import de.upb.crypto.zeroknowledge.helpers.ModelMap
import de.upb.crypto.zeroknowledge.zeroKnowledge.ZeroKnowledgeFactory
import org.eclipse.emf.ecore.EObject
import de.upb.crypto.zeroknowledge.helpers.ModelHelper

import de.upb.crypto.math.expressions.*;
import de.upb.crypto.zeroknowledge.helpers.ModelPrinter
import de.upb.crypto.zeroknowledge.helpers.VariableEnvironment
import de.upb.crypto.zeroknowledge.helpers.Type
import de.upb.crypto.zeroknowledge.helpers.TypeResolution

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class ZeroKnowledgeGenerator extends AbstractGenerator {
	
	HashMap<EObject, Type> types;

	Set<String> variables;
	Set<String> literals;
	
	StringBuilder codeBuilder;
	StringBuilder importBuilder;
	StringBuilder functionBuilder;
	StringBuilder exponentVariableBuilder;
	StringBuilder groupVariableBuilder;
	StringBuilder literalBuilder;
	
	String OPERATOR_EQUAL = "=";
	String OPERATOR_INEQUAL = "!=";
	String OPERATOR_LESS = "<";
	String OPERATOR_GREATER = ">";
	String OPERATOR_LESSEQUAL = "<=";
	String OPERATOR_GREATEREQUAL = ">=";
	String NEWLINE = "\n";
	String INDENT = "  ";
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
	
		variables = new HashSet<String>;
		literals = new HashSet<String>;
	
		codeBuilder = new StringBuilder();
		importBuilder = new StringBuilder();
		functionBuilder = new StringBuilder();
		exponentVariableBuilder = new StringBuilder();
		groupVariableBuilder = new StringBuilder();
		literalBuilder = new StringBuilder();
	
		// Perform model transformations
		val Model model = resource.getContents().iterator().next() as Model;
		val boolean inline = false;
		
		// If option is set, inline all functions
		if (inline) ModelHelper.inlineFunctions(model);
		
		// Replace all subtraction operations with sum operations of negative nodes
		ModelHelper.normalizeNegatives(model);

	
		types = TypeResolution.resolveTypes(model);	

		ModelPrinter.print(model);

		generateImports();
		generateFunctions(model, new BranchState());
		val String code = generateCode(model, new BranchState());
	
		codeBuilder.append(importBuilder);
		codeBuilder.append(NEWLINE);
		codeBuilder.append(functionBuilder);
		codeBuilder.append(NEWLINE);
		codeBuilder.append(literalBuilder);
		codeBuilder.append(NEWLINE);
		codeBuilder.append(exponentVariableBuilder);
		codeBuilder.append(NEWLINE);
		codeBuilder.append(groupVariableBuilder);
		codeBuilder.append(NEWLINE);
		codeBuilder.append(code);
		
		System.out.println(codeBuilder.toString());
				
		if (context.getCancelIndicator.isCanceled()) return;

//		if (!inline) return;
		
		fsa.generateFile('first.java', codeBuilder.toString());
	}
	
	// Generates all required import statements
	def void generateImports() {
		importBuilder.append(
			'''
			import de.upb.crypto.math.expressions.*;
			'''
		)
	}
	
	// Generates the Java equivalent of all user defined functions
	def void generateFunctions(Model model, BranchState state) {
		for (FunctionDefinition function : model.getFunctions()) {




			val Map<String, Boolean> mapping = new HashMap<String, Boolean>();
			
			ModelMap.preorder(function.getBody(), [EObject node |
				if (node instanceof Sum) {
					ModelMap.postorder(node, [EObject child |
						if (child instanceof Variable) {
							val String name = child.getName();
							if (!mapping.containsKey(name)) {
								mapping.put(name, true);
							}
						}
						
					]);
				} else if (node instanceof Power) {
					ModelMap.postorder(node.getRight(), [EObject child |
						if (child instanceof Variable) {
							val String name = child.getName();
							if (!mapping.containsKey(name)) {
								mapping.put(name, true);
							}
						}
					]);
				}
				
			]);
			
			ModelMap.postorder(function.getBody(), [EObject node |
				if (node instanceof Variable) {
					val String name = node.getName();
					if (!mapping.containsKey(name)) {
						mapping.put(name, false);
					}
				}
				
			]);
				
//			val String type = (mapping.get("test").booleanValue() ? "ExponentVariableExpr" : "GroupVariablExpr"); 
//			
			functionBuilder.append(
				'''
				private static «function.getName()»(«FOR Parameter parameter : function.getParameterList().getParameters() SEPARATOR ', '»«IF mapping.containsKey(parameter.getName()) === true && mapping.get(parameter.getName())»ExponentVariableExpr«ELSE»GroupVariablExpr«ENDIF» «parameter.getName()»«ENDFOR») {
				  «generateCode(function.getBody(), state)»;
				}
				'''
			);
			// Throw a console warning above if the type cannot be determined for the variable
			// Or possibly move this warning to validation
			
		}
	}
	
	// Generates the Java code for the main expression and for the bodies of user functions
	def dispatch String generateCode(Model node, BranchState state) {
		return '''«generateCode(node.getProof(), state)»;''';
	}
	
	def dispatch String generateCode(Conjunction conjunction, BranchState state) {
		val String left = generateCode(conjunction.getLeft(), state);
		val String right = generateCode(conjunction.getRight(), state);
		
		return 
		'''
		«left»
		.and(«right»)''';
	}
	
	def dispatch String generateCode(Disjunction disjunction, BranchState state) {
		val String left = generateCode(disjunction.getLeft(), state);
		val String right = generateCode(disjunction.getRight(), state);
		
		return '''«left».or(«right»)''';
		}
	
	def dispatch String generateCode(Comparison comparison, BranchState state) {
		val String left = generateCode(comparison.getLeft(), state);
		val String right = generateCode(comparison.getRight(), state);		
		var String operator;
		
		switch comparison.getOperation() {
			case OPERATOR_EQUAL: operator = "equals"
			case OPERATOR_INEQUAL: operator = "notequals"
			case OPERATOR_LESS: operator = "lessthan"
			case OPERATOR_GREATER: operator = "greaterthan"
			case OPERATOR_LESSEQUAL: operator = "lessthanequal"
			case OPERATOR_GREATEREQUAL: operator = "greaterthanequal"
		}
		
		return '''«left».«operator»(«right»)''';
	}
	
	def dispatch String generateCode(Sum sum, BranchState state) {
		
		val newState = new BranchState(state);
//		newState.setExponentContext();

		val String left = generateCode(sum.getLeft(), newState);
		val String right = generateCode(sum.getRight(), newState);
		
		return '''«left».add(«right»)''';
	}
	
	def dispatch String generateCode(Product product, BranchState state) {

		val String left = generateCode(product.getLeft(), state);
		val String right = generateCode(product.getRight(), state);
		
		if (types.get(product) === Type.EXPONENT) {
			return '''«left».mul(«right»)'''
		} else {
			return '''«left».op(«right»)''';
		}

	}
	
	def dispatch String generateCode(Power power, BranchState state) {
		
		val String left = generateCode(power.getLeft(), state);
		val String right = generateCode(power.getRight(), state);
		
		return '''«left».pow(«right»)''';		
	}
	
	def dispatch String generateCode(StringLiteral node, BranchState state) {
		return '''«node.getValue()»''';
	}
	
	def dispatch String generateCode(Tuple node, BranchState state) {
		return '''«FOR element : node.getElements() SEPARATOR ', '»«generateCode(element, state)»«ENDFOR»'''
	}

	def dispatch String generateCode(Negative node, BranchState state) {
		
		val String term = generateCode(node.getTerm(), state);
		
		return '''«term».neg()''';		
	}
	
	def dispatch String generateCode(FunctionCall call, BranchState state) {
		val String name = ModelHelper.convertToJavaName(call.getName());
		
		return '''«name»(«FOR argument : call.getArguments() SEPARATOR ','»generateCode(«argument»)«ENDFOR»)'''
	}
	
	def dispatch String generateCode(Variable variable, BranchState state) {
		val String name = ModelHelper.convertToJavaName(variable.getName());
		
		
		if (!variables.contains(name)) {
			variables.add(name);
			
			if (types.get(variable) === Type.EXPONENT) {
				
			}

		}
		
		
		if (true) {
//		if (state.isExponentContext()) {
			if (!variables.contains(name)) {
				variables.add(name);
				exponentVariableBuilder.append(
					'''
					ExponentVariableExpr «name» = new ExponentVariableExpr(«name»);
					'''
				);
			}
		} else {
			if (!variables.contains(name)) {
				variables.add(name);
				groupVariableBuilder.append(
					'''
					GroupVariableExpr «name» = new GroupVariableExpr("«name»");
					'''
				);
			}
		}
		
		variables.add(name);
		
		return name;
	}
	
	def dispatch String generateCode(NumberLiteral node, BranchState state) {
		
		val String name = "val_" + node.getValue();
		
		if (!literals.contains(name)) {
			literals.add(name);
			literalBuilder.append('''
				ExponentLiteralExpr «name» = new ExponentLiteralExpr(«node.getValue()»);
			''');
		}

		return name;
	}
	
	def dispatch String generateCode(Brackets node, BranchState state) {
		return generateCode(node.getContent(), state);
	}
	
}
