grammar de.upb.crypto.zeroknowledge.ZeroKnowledge hidden(WHITESPACE, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate zeroKnowledge "http://www.upb.de/crypto/zeroknowledge/ZeroKnowledge"

/*
 * This file specifies the syntax and grammar of the 0K language, and is written using
 * the Xtend grammar language
 * 
 * See https://www.eclipse.org/Xtext/documentation/301_grammarlanguage.html
 */

Model returns Model:
  functions+=(FunctionDefinition)* witnessList=WitnessList ';'? proof=Expression ';'?;

FunctionDefinition returns FunctionDefinition:
  name=IDENTIFIER parameterList=ParameterList '{' body=Expression ';'? '}' ';'?;

ParameterList returns ParameterList:
  '(' (parameters+=Parameter (',' parameters+=Parameter)*)? symbol=')';

Parameter returns Parameter:
  name=IDENTIFIER;
  
WitnessList returns WitnessList:
  '(' (witnesses+=Witness (',' witnesses+=Witness)*)? symbol=')';

Witness returns Witness:
  name=IDENTIFIER;

Expression:
  Conjunction;

Conjunction returns Expression:
  Disjunction ({Conjunction.left=current} operation='&' right=Disjunction)*;

Disjunction returns Expression:
  Comparison ({Disjunction.left=current} operation='|' right=Comparison)* (protocol=PROTOCOL)?;

Comparison returns Expression:
  Sum (({Comparison.left=current} operation='!=' | {Comparison.left=current} operation='=' | {Comparison.left=current} operation='>=' | {Comparison.left=current} operation='<=' | {Comparison.left=current} operation='>' | {Comparison.left=current} operation='<') right=Sum)?;

Sum returns Expression:
  Product (({Sum.left=current} operation='+' | {Sum.left=current} operation='-') right=Product)*;

Product returns Expression:
  Power (({Product.left=current} operation='*' | {Product.left=current} operation='/') right=Power)*;
 
Power returns Expression:
	Construct ({Power.left = current} operation='^' right=Power)?;

Construct returns Expression:
  StringLiteral | Tuple | Negative;
  
StringLiteral returns StringLiteral:
  value=STRING_LITERAL;

Tuple returns Expression:
  =>({Tuple} '(' elements+=Conjunction ',') elements+=Conjunction (',' elements+=Conjunction)* ')';

Negative returns Expression:
  {Negative} operation='-' term=Value | Value;

Value returns Expression:
  FunctionCall | Variable | NumberLiteral | '(' Brackets ')';

FunctionCall returns Expression:
  {FunctionCall} (->(name=IDENTIFIER '(') (arguments+=Argument (',' arguments+=Argument)*)? ')');

Argument returns Expression:
  {Argument} expression=Conjunction;

Variable returns Variable:
  name=IDENTIFIER;

/*
 * This object will not be created during parsing, but Variable objects
 * corresponding to arguments in function definitions will be converted
 * to LocalVariable objects after parsing
 */
LocalVariable returns Variable:
  {LocalVariable} name=IDENTIFIER function=IDENTIFIER;

/*
 * This object will not be created during parsing, but Variable objects
 * corresponding to witnesses will be converted to WitnessVariable
 * objects after parsing
 */
WitnessVariable returns Variable:
  {WitnessVariable} name=IDENTIFIER;

NumberLiteral returns NumberLiteral:
  value=INT;

Brackets returns Expression:
	{Brackets} content=Expression;
	
terminal INT returns ecore::EInt:
  ('0'..'9')+;

terminal ML_COMMENT:
  '/*' -> '*/';

terminal SL_COMMENT:
  '//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WHITESPACE:
  (' '|'\t'|'\r'|'\n')+;

terminal IDENTIFIER:
	('a'..'z'|'A'..'Z') ('a'..'z'|'A'..'Z'|'0'..'9'|'_'|'\'')*;

terminal STRING_LITERAL:
  '"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"';

terminal PROTOCOL:
	('a'..'z'|'A'..'Z'|'0'..'9'|'_'|'\'')+; 