package de.upb.crypto.zeroknowledge.type

import java.util.HashMap
import org.eclipse.emf.ecore.EObject
import de.upb.crypto.zeroknowledge.zeroKnowledge.Model
import de.upb.crypto.zeroknowledge.model.ModelHelper
import de.upb.crypto.zeroknowledge.zeroKnowledge.Tuple
import de.upb.crypto.zeroknowledge.model.ModelMap
import de.upb.crypto.zeroknowledge.zeroKnowledge.FunctionDefinition
import de.upb.crypto.zeroknowledge.zeroKnowledge.Parameter
import de.upb.crypto.zeroknowledge.zeroKnowledge.FunctionCall
import de.upb.crypto.zeroknowledge.zeroKnowledge.Conjunction
import de.upb.crypto.zeroknowledge.zeroKnowledge.Comparison
import de.upb.crypto.zeroknowledge.zeroKnowledge.Disjunction
import de.upb.crypto.zeroknowledge.zeroKnowledge.Sum
import de.upb.crypto.zeroknowledge.zeroKnowledge.Product
import de.upb.crypto.zeroknowledge.zeroKnowledge.Argument

class TupleResolution {
	
	static private HashMap<EObject, Integer> tuples;
	static private HashMap<EObject, Type> types;
	
	def static HashMap<EObject, Integer> getTuples() {
		return tuples;
	}
	
	def static HashMap<EObject, Integer> resolveTuples(Model model, HashMap<EObject, Type> types) {
		
		tuples = new HashMap<EObject, Integer>();
		
		val tupleNodes = ModelHelper.getAllTuples(model);
		
		for (Tuple tuple : tupleNodes) {
			backpropagate(tuple, tuple.getElements().size());
		}
		
		fillScalar(model);
		
		return tuples;
	}
	
	def static private void backpropagate(EObject node, int size) {
		
		if (tuples.containsKey(node)) return;
		
		if (
			node instanceof Model ||
			node instanceof FunctionDefinition ||
			node instanceof FunctionCall ||
			node instanceof Conjunction ||
			node instanceof Disjunction
		) return;
		
		if (node instanceof Comparison) {
			if (!tuples.containsKey(node.getLeft())) {
				fillTuple(node.getLeft(), size);
			}
			if (!tuples.containsKey(node.getRight())) {
				fillTuple(node.getLeft(), size);
			}
			return;
		}
		
		tuples.put(node, size);
		
		switch node {
			Sum: {
				if (!tuples.containsKey(node.getLeft())) {
					fillTuple(node.getLeft(), size);
				}
				if (!tuples.containsKey(node.getRight())) {
					fillTuple(node.getLeft(), size);
				}
			}
			Product: {
				if (types.get(node) === Type.GROUP_ELEMENT) {
					if (!tuples.containsKey(node.getLeft())) {
						fillTuple(node.getLeft(), size);
					}
					if (!tuples.containsKey(node.getRight())) {
						fillTuple(node.getLeft(), size);
					}
				}
			}
			FunctionDefinition: {
				
			}
			FunctionCall: {
				
			}
			Argument: {
				
			}
			
			default: {
				backpropagate(node.eContainer(), size);
			}
		}
		
		
		
	}
	
	def static private void fillTuple(EObject node, int size) {
		
		if (tuples.containsKey(node)) return;
		
		switch node {
			LocalVariable: {
				
				
			}
			
			Variable: {
				
			}
		}
		
	}
	
	
	// Default	
	def static private void fillScalar(Model model) {
		fillScalarHelper(model.getProof());
		
		for (FunctionDefinition function : model.getFunctions()) {
			fillScalarHelper(function.getBody());
			
			for (Parameter parameter : function.getParameterList.getParameters()) {
				if (!tuples.containsKey(parameter)) {
					tuples.put(parameter, 0);
				}
			}
		}
	}
	def static private fillScalarHelper(EObject node) {
		ModelMap.preorder(node, [EObject child |
			if (!tuples.containsKey(child)) {
				tuples.put(child, 0);
			}
		]);
	}
	
}