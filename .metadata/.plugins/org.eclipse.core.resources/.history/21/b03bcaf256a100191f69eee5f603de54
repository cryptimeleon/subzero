package de.upb.crypto.zeroknowledge.helpers

import org.eclipse.emf.ecore.EObject

class ModelMap {
	// Recurses through the abstract syntax tree and applies the function to each node
	// Applies the function to the node, and then to its subtrees	
	def static void preorder(EObject node, (EObject) => void function) {
		
		// Apply function
		function.apply(node);
		
		// Recurse through child nodes
		for (EObject child : node.eContents()) {
			preorder(child, function);
		}
	}
		
	// Recurses through the abstract syntax tree and applies the function to each node
	// Applies to all of a node's subtrees before applying the function to the node
	def static void postorder(EObject node, (EObject) => void function) {
		
		// Recurse through child nodes
		for (EObject child : node.eContents()) {
			postorder(child, function);
		}
		
		// Apply function
		function.apply(node);
	}
	
	def static boolean preorderSatisfies(EObject node, (EObject) => void function) {
		
		// Recurse through child nodes
		for (EObject child : node.eContents()) {
			if (preorderSatisfies(child, function)) {
				return true;
			}
		}
		
	}
	
	def static void postorderSatisfies(EObject node, (EObject) => void function) {
		
	}
	
	
	// Recurses through the abstract syntax tree and applies the function to each node
	// Applies to all of a node's subtrees before applying the function to the node
	def static void preorderWithState(EObject node, BranchState state, (EObject, BranchState) => void function) {
		
		state.updateState(node);
		
		// Apply function
		function.apply(node, state);
		
		// Recurse through child nodes
		for (EObject child : node.eContents()) {
			preorderWithState(child, new BranchState(state), function);
		}
	}
	
	// Recurses through the abstract syntax tree and applies the function to each node
	// Applies to all of a node's subtrees before applying the function to the node
	def static void postorderWithState(EObject node, BranchState state, (EObject, BranchState) => void function) {
		
		state.updateState(node);
		
		// Recurse through child nodes
		for (EObject child : node.eContents()) {
			postorderWithState(child, state, function);
		}
		
		// Apply function
		function.apply(node, state);
	}
}