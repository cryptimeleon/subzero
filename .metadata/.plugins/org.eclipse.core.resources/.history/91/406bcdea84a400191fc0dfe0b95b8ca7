/*
 * generated by Xtext 2.17.0
 */
package de.upb.crypto.zeroknowledge.validation

import java.util.Map;
import java.util.HashMap;
import java.util.Iterator;
import java.util.HashSet;
import java.util.List;
import java.util.ArrayList;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;

// Temporary imports, remove later
import de.upb.crypto.zeroknowledge.latex.LatexPreview;
import de.upb.crypto.zeroknowledge.helpers.PredefinedFunctionsHelper;
import de.upb.crypto.zeroknowledge.helpers.ModelPrinter;

import de.upb.crypto.zeroknowledge.helpers.ModelMap
import de.upb.crypto.zeroknowledge.helpers.ModelHelper;
import de.upb.crypto.zeroknowledge.helpers.FunctionSignature;

import de.upb.crypto.zeroknowledge.zeroKnowledge.Comparison;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Conjunction;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Disjunction;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Model;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Expression;
import de.upb.crypto.zeroknowledge.zeroKnowledge.FunctionCall;
import de.upb.crypto.zeroknowledge.zeroKnowledge.FunctionDefinition;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Brackets;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Negative;
import de.upb.crypto.zeroknowledge.zeroKnowledge.NumberLiteral;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Parameter;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Power;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Product;
import de.upb.crypto.zeroknowledge.zeroKnowledge.StringLiteral;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Sum;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Tuple;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Variable;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Witness;
import de.upb.crypto.zeroknowledge.zeroKnowledge.ZeroKnowledgePackage;
import de.upb.crypto.zeroknowledge.helpers.BranchState
import de.upb.crypto.zeroknowledge.zeroKnowledge.WitnessList
import de.upb.crypto.zeroknowledge.zeroKnowledge.ParameterList
import java.util.Set
import de.upb.crypto.zeroknowledge.helpers.Type

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class ZeroKnowledgeValidator extends AbstractZeroKnowledgeValidator {
	
	var Map<EObject, Type> nodeType;
	var Map<String, FunctionSignature> predefinedFunctions = PredefinedFunctionsHelper.getAllPredefinedFunctions();
	var Map<String, FunctionSignature> userFunctions;
	var HashSet<String> witnessNames;
	
	@Check
	def void checkModel(Model model) {
		
		ModelPrinter.print(model);
		
		userFunctions = fetchUserFunctions(model);
		witnessNames = fetchWitnessNames(model);
		
		ModelMap.preorderWithState(model, new BranchState(), [EObject node, BranchState state |
			checkNode(node, state)
		]);
	}
	
	def HashMap<String, FunctionSignature> fetchUserFunctions(Model model) {
		val HashMap<String, FunctionSignature> functions = new HashMap<String, FunctionSignature>();
		for (FunctionDefinition function: model.getFunctions()) {
			functions.put(function.getName(), new FunctionSignature(function.getName(), "", function.getParameterList().getParameters().size()));
		}
		
		return functions;
	}
	
	def HashSet<String> fetchWitnessNames(Model model) {
		val HashSet<String> witnesses = new HashSet<String>();
		for (Witness witness : model.getWitnessList().getWitnesses()) {
			witnesses.add(witness.getName());
		}
		
		return witnesses;
	}
	
	def dispatch void checkNode(Model model, BranchState state) {
		checkFunctionNamesAreUnique(model)
		
		System.out.println("model");
		return;
	}
	
	def dispatch void checkNode(FunctionDefinition function, BranchState state) {
		checkFunctionNameFormat(function);
		checkFunctionNameIsNotPredefined(function);
		checkFunctionIsCalled(function);
		checkParametersAreUsed(function);
				
		System.out.println("function");
		return;
	}

	def dispatch void checkNode(ParameterList parameterList, BranchState state) {
		checkFunctionParameterNamesAreUnique(parameterList);
		
		System.out.println("parameterlist");
		return;
	}
	
	def dispatch void checkNode(Parameter parameter, BranchState state) {
		checkParameterNameFormat(parameter);
		
		System.out.println("parameter");
		return;
	}
	
	def dispatch void checkNode(WitnessList witnessList, BranchState state) {
		checkWitnessListIsNonempty(witnessList);
		checkWitnessNamesAreUnique(witnessList);
		
		System.out.println("witnesslist");
		return;
	}
	
	def dispatch void checkNode(Witness witness, BranchState state) {
		checkWitnessNameFormat(witness);
		
		System.out.println("witness");
		return;
	}
	
	def dispatch void checkNode(Conjunction conjunction, BranchState state) {
		checkValidConjunctionPosition(conjunction, state);
		
		System.out.println("conjunction");
		return;
	}
	
	def dispatch void checkNode(Disjunction disjunction, BranchState state) {
		checkValidDisjunctionPosition(disjunction, state);

		System.out.println("disjunction");
		return;
	}
	
	def dispatch void checkNode(Comparison comparison, BranchState state) {
		checkValidComparisonPosition(comparison, state);
		
		System.out.println("comparison");
		return;
	}
	
	def dispatch void checkNode(Sum sum, BranchState state) {
		checkAlgebraicIsInComparisonOrFunction(sum, state);
		
		System.out.println("sum");
		return;
	}
	
	def dispatch void checkNode(Product product, BranchState state) {
		checkAlgebraicIsInComparisonOrFunction(product, state);
		
		System.out.println("product");
		return;
	}
	
	def dispatch void checkNode(Power power, BranchState state) {
		checkAlgebraicIsInComparisonOrFunction(power, state);
		
		System.out.println("power");
		return;
	}
	
	def dispatch void checkNode(StringLiteral stringLiteral, BranchState state) {
		checkValidStringLiteralPosition(stringLiteral, state);
		
		System.out.println("string");
		return;
	}
	
	def dispatch void checkNode(Tuple tuple, BranchState state) {
		checkAlgebraicIsInComparisonOrFunction(tuple, state);
		
		System.out.println("tuple");
		return;
	}
	
	def dispatch void checkNode(Negative negative, BranchState state) {
		checkAlgebraicIsInComparisonOrFunction(negative, state);
		
		System.out.println("negative");
		return;
	}
	
	def dispatch void checkNode(FunctionCall call, BranchState state) {
		
		checkValidFunctionCall(call);
		checkFunctionHasNoUserFunctionCalls(call, state);
		
		checkAlgebraicIsInComparisonOrFunction(call, state);
		
		return;
	}
	
	def dispatch void checkNode(Variable variable, BranchState state) {
		checkVariableNameFormat(variable);
		
		checkAlgebraicIsInComparisonOrFunction(variable, state);
		
		System.out.println("variable");
		return;
	}
	
	def dispatch void checkNode(NumberLiteral number, BranchState state) {
		
		
		System.out.println("number");
		return;
	}
	
	def dispatch void checkNode(Brackets brackets, BranchState state) {
		System.out.println("brackets");
		return;
	}
	
	


	/*
	 * Validate the format of identifier names
	 */
	// User defined function names must start with a letter, and contain only letters and numbers
	def private void checkFunctionNameFormat(FunctionDefinition function) {
		if (function.getName().contains("_")) {
			error("Function names can not contain underscores", function,
				ZeroKnowledgePackage.Literals.FUNCTION_DEFINITION__NAME);
		}
		if (function.getName().contains("'")) {
			error("Function names can not contain single quotes", function,
				ZeroKnowledgePackage.Literals.FUNCTION_DEFINITION__NAME);
		}
	}

	// Witness names must start with a letter, and only contain letters, numbers, at most 1 underscore
	// (to denote subscript) and any number of single quotes at the end
	def private void checkWitnessNameFormat(Witness witness) {
		var List<String> errors = nameFormatErrors(witness.getName(), "Witness");
		for (val Iterator<String> iterator = errors.iterator(); iterator.hasNext();) {
			error(iterator.next(), witness, ZeroKnowledgePackage.Literals.WITNESS__NAME);
		}
	}

	// Variable names must start with a letter, and only contain letters, numbers, at most 1 underscore
	// (to denote subscript) and any number of single quotes at the end
	def private void checkVariableNameFormat(Variable variable) {
		var List<String> errors = nameFormatErrors(variable.getName(), "Variable");
		for (val Iterator<String> iterator = errors.iterator(); iterator.hasNext();) {
			error(iterator.next(), variable, ZeroKnowledgePackage.Literals.VARIABLE__NAME);
		}
	}

	// Parameter names must start with a letter, and only contain letters, numbers, at most 1 underscore
	// (to denote subscript) and any number of single quotes at the end
	def private void checkParameterNameFormat(Parameter parameter) {
		var List<String> name_errors = nameFormatErrors(parameter.getName(), "Parameter");
		for (String name_error : name_errors) {
			error(name_error, parameter, ZeroKnowledgePackage.Literals.PARAMETER__NAME);
		}
	}

	// Helper function for checkWitnessNameFormat, checkVariableNameFormat, checkParameterNameFormat
	def private List<String> nameFormatErrors(String identifier, String type) {
		var List<String> name_errors = new ArrayList<String>();

		var int underscores = 0;
		for (var int i = 0; i < identifier.length(); i++) {
			if (identifier.charAt(i) == '_') {
				underscores++;
				if (underscores > 1) {
					name_errors.add(type + " name can contain at most 1 underscore");
					i = identifier.length();
				}
			}
		}

		var boolean quote = false;
		for (var int i = 0; i < identifier.length(); i++) {
			if (quote && identifier.charAt(i) != '\'') {
				name_errors.add(type + " name can only contain single quotes at the end of the name");
			} else if (identifier.charAt(i) == '\'') {
				quote = true;
			}
		}

		if (identifier.charAt(identifier.length() - 1) == '_') {
			name_errors.add(type + " name can not end with an underscore");
		}

		return name_errors;
	}

	/*
	 * Validate the uniqueness of identifiers
	 */
	// User defined function names must be unique
	def private void checkFunctionNamesAreUnique(Model model) {
		val HashSet<String> functions = new HashSet<String>();
		for (FunctionDefinition function : model.getFunctions()) {
			val String name = function.getName();
			if (functions.contains(name)) {
				error("Function names must be unique", function, ZeroKnowledgePackage.Literals.FUNCTION_DEFINITION__NAME);
			} else {
				functions.add(name);
			}
		}
	}

	// User defined functions cannot have the same name as a predefined function
	def private void checkFunctionNameIsNotPredefined(FunctionDefinition function) {
		if (FunctionSignature.getAllNames(predefinedFunctions).contains(function.getName())) {
			error("Function name is already used by a predefined function", function, ZeroKnowledgePackage.Literals.FUNCTION_DEFINITION__NAME);
		}
	}

	// Witness names must be unique
	def private void checkWitnessNamesAreUnique(WitnessList witnessList) {
		val Set<String> witnesses = new HashSet<String>();
		for (Witness witness : witnessList.getWitnesses()) {
			val String name = witness.getName();
			if (witnesses.contains(name)) {
				error("Witness names must be unique", witness, ZeroKnowledgePackage.Literals.WITNESS__NAME);
			} else {
				witnesses.add(name);				
			}
		}
	}


	// Function parameter names must be unique within a function signature
	def private void checkFunctionParameterNamesAreUnique(ParameterList parameterList) {
		val Set<String> parameters = new HashSet<String>();
		for (Parameter parameter : parameterList.getParameters()) {
			val String name = parameter.getName();
			if (parameters.contains(name)) {
				error("Function parameters must be unique within a function's signature", parameterList, ZeroKnowledgePackage.Literals.FUNCTION_DEFINITION__PARAMETER_LIST);
			}
		}
	}

	/*
	 * Validate user function definitions
	 */
	// Function definitions cannot contain function calls to other user functions
	def private void checkFunctionHasNoUserFunctionCalls(FunctionCall call, BranchState state) {
		if (state.hasFunctionDefinitionAncestor()) {
			error("Can not call user functions from within a user function", call, ZeroKnowledgePackage.Literals.FUNCTION_CALL__NAME);
		}
	}

	// Every function parameter should be used at least once in the function definition
	def private void checkParametersAreUsed(FunctionDefinition function) {
		for (Parameter parameter: function.getParameterList().getParameters()) {
			if (!ModelMap.postorderAny(function.getBody(), [EObject node |
				if (node instanceof Variable) {
					if (node.getName() == parameter.getName()) {
						return true;
					}
				}
				return false;
			])) {
				warning('''Parameter '«parameter.getName()»' is not used within the function definition''', parameter, ZeroKnowledgePackage.Literals.PARAMETER__NAME);
			}
		}
	}

	// User defined functions should be called at least once in the proof expression
	def private void checkFunctionIsCalled(FunctionDefinition function) {
		val String function_name = function.getName();
		val Model root = ModelHelper.getRoot(function);

		if (!ModelMap.postorderAny(root.getProof(), [ EObject node |
			if (node instanceof FunctionCall) {
				if (node.getName() == function_name) {
					return true;
				}
			}
			return false;
		])) {
			warning(
				"Function is never used in the proof expression, and will not be included in the generated Java code", function,
				ZeroKnowledgePackage.Literals.FUNCTION_DEFINITION__NAME);
		}
	}

	/*
	 * Validate the witness list
	 */
	// The witness list must contain at least one witness
	def private void checkWitnessListIsNonempty(WitnessList witnessList) {
		if (witnessList.getWitnesses().size() === 0) {
			error("The witness list must include at least one witness", witnessList,
				ZeroKnowledgePackage.Literals.WITNESS_LIST__WITNESSES);
		}
	}

	/*
	 * Validate function calls
	 */
	// Function calls must reference either a user defined function or a predefined function
	// The number of arguments in a function call must match the number of parameters in the function definition
	
	def private void checkValidFunctionCall(FunctionCall call) {
		val String name = call.getName();
		var FunctionSignature signature = userFunctions.get(name);
		if (signature !== null) {
			if (signature.getParameterCount() !== call.getArguments().size()) {
				error(
					'''The number of arguments in the function call («call.getArguments().size()») must match the number of parameters in the function definition («signature.getParameterCount()»)''', call,
					ZeroKnowledgePackage.Literals.FUNCTION_CALL__ARGUMENTS);
			}
			return;
		}
		
		signature = predefinedFunctions.get(name);
		if (signature !== null) {
			if (signature.getParameterCount() !== call.getArguments().size()) {
				error(
					"The number of arguments in the function call must match the number of parameters in the function definition", call,
					ZeroKnowledgePackage.Literals.FUNCTION_CALL__ARGUMENTS);
			}
			return;
		}
		error("Function call references a function that does not exist", call,
			ZeroKnowledgePackage.Literals.FUNCTION_CALL__NAME);
	}
	
	/*
	 * Grammar structure
	 */
	// String literals must be directly nested within a tuple, a comparison, or a function call
	def private void checkValidStringLiteralPosition(StringLiteral stringLiteral, BranchState state) {
		val EObject parent = state.getParent();
		if (!(parent instanceof Tuple || parent instanceof Comparison || parent instanceof FunctionCall)) {
			error("String literals must be contained within a tuple, a function call, or a comparison expression", stringLiteral,
				ZeroKnowledgePackage.Literals.STRING_LITERAL__VALUE);
		}
	}

	// Conjunctions cannot be nested within algebraic expressions or comparison expressions
	def private void checkValidConjunctionPosition(Conjunction conjunction, BranchState state) {
		if (isIllegallyNested(conjunction, state)) {
			error("Conjunctions can not be nested within algebraic or comparison expressions", conjunction,
				ZeroKnowledgePackage.Literals.CONJUNCTION__OPERATION);
		}
	}

	// Disjunctions cannot be nested within algebraic expressions or comparison expressions
	def private void checkValidDisjunctionPosition(Disjunction disjunction, BranchState state) {
		if (isIllegallyNested(disjunction, state)) {
			error("Disjunctions can not be nested within algebraic or comparison expressions", disjunction,
				ZeroKnowledgePackage.Literals.DISJUNCTION__OPERATION);
		}
	}

	// Comparisons cannot be nested within algebraic expressions or comparison expressions
	def private void checkValidComparisonPosition(Comparison comparison, BranchState state) {
		if (isIllegallyNested(comparison, state)) {
			error("Comparisons can not be nested within algebraic expressions or other comparison expressions", comparison,
				ZeroKnowledgePackage.Literals.COMPARISON__OPERATION);
		}
	}
	
	
	def private boolean isIllegallyNested(EObject node, BranchState state) {
		val EObject parent = state.getParent();
		if (parent instanceof Model || parent instanceof FunctionDefinition || parent instanceof Conjunction || parent instanceof Disjunction) {
			return true;
		}
		return false;
	}

	// Helper function for checkValidConjunctionPosition, checkValidDisjunctionPosition, checkValidComparisonPosition
//	def private boolean isIllegallyNested(EObject node) {
//		var EObject parent = node.eContainer();
//		if (parent instanceof Model || parent instanceof FunctionDefinition) {
//			return false;
//		} else if (!(parent instanceof Conjunction || parent instanceof Disjunction)) {
//			return true;
//		} else {
//			return isIllegallyNested(parent);
//		}
//	}

//	def private void checkAlgebraicPosition(EObject node, BranchState state) {
//		if (state.hasComparisonBeforePropositional()) {
//			error("Algebraic expression must be nested within a comparison expression before being nested within a propositional expression", null);
//		}
//	}
	
	
	// Algebraic expressions must be nested within a comparison expression before being nested within a propositional expression
	@Check
	def void checkAlgebraicPosition(EObject node) {
		if (!ModelHelper.isAlgebraic(node) || node instanceof FunctionCall) {
			return;
		}

		if (!hasComparisonBeforePropositional(node.eContainer())) {
			error(
				"Algebraic expression must be nested within a comparison expression before being nested within a propositional expression",
				null);
		}
	}

	// Helper function for checkAlgebraicPosition
	def private boolean hasComparisonBeforePropositional(EObject node) {
		if (node instanceof Conjunction || node instanceof Disjunction) {
			return false;
		} else if (node instanceof Comparison || node instanceof FunctionCall || node instanceof Model) {
			return true;
		}
		return hasComparisonBeforePropositional(node.eContainer());
	}

	// Algebraic expressions in the proof expression must be nested within a comparison expression or function call
	def private void checkAlgebraicIsInComparisonOrFunction(EObject object, BranchState state) {
		if (!(state.hasComparisonAncestor() || state.hasFunctionDefinitionAncestor() || state.hasFunctionCallAncestor())) {
			error("Algebraic expressions must be nested within a comparison expression", null);
		}
	}
	

	@Check
	def void checkNumberLiteralIsExponent(NumberLiteral literal) {
		if (!ModelHelper.hasSumOrPowerAncestor(literal)) {
			error(
				"Number literals must be contained within a sum expression or the right operand of a power expression",
				ZeroKnowledgePackage.Literals.NUMBER_LITERAL__VALUE);
		}
	}

	// Function calls which return a boolean value cannot be nested within algebraic expressions, and
	// function calls which return algebraic values must be nested within a comparison expression
//	@Check
//	def void checkValidFunctionCallPosition(FunctionCall call, BranchState state) {
//		if (ModelHelper.isBooleanFunction(call)) {
//			if (isIllegallyNested(call, state)) {
//				error("Functions which return a boolean value can not be nested within algebraic expressions", call,
//					ZeroKnowledgePackage.Literals.FUNCTION_CALL__NAME);
//			}
//		} else {
//			if (!ModelHelper.hasComparisonOrFunctionAncestor(call)) {
//				error("Functions which return an algebraic value must be nested within a comparison expression", call,
//					ZeroKnowledgePackage.Literals.FUNCTION_CALL__NAME);
//			}
//		}
//	}
	

//	@Check
//	def void checkInline(Model model) {
//		ModelPrinter.print(model);
//		var LatexPreview output = new LatexPreview(model, false);
//		error(output.getRawLatex(), null);
//	}	
}
