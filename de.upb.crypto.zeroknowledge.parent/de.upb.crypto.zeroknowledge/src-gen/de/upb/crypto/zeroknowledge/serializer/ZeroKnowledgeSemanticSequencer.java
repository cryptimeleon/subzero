/*
 * generated by Xtext 2.17.0
 */
package de.upb.crypto.zeroknowledge.serializer;

import com.google.inject.Inject;
import de.upb.crypto.zeroknowledge.services.ZeroKnowledgeGrammarAccess;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Argument;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Brackets;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Comparison;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Conjunction;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Disjunction;
import de.upb.crypto.zeroknowledge.zeroKnowledge.FunctionCall;
import de.upb.crypto.zeroknowledge.zeroKnowledge.FunctionDefinition;
import de.upb.crypto.zeroknowledge.zeroKnowledge.LocalVariable;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Model;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Negative;
import de.upb.crypto.zeroknowledge.zeroKnowledge.NumberLiteral;
import de.upb.crypto.zeroknowledge.zeroKnowledge.ParameterList;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Power;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Product;
import de.upb.crypto.zeroknowledge.zeroKnowledge.StringLiteral;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Sum;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Tuple;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Variable;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Witness;
import de.upb.crypto.zeroknowledge.zeroKnowledge.WitnessList;
import de.upb.crypto.zeroknowledge.zeroKnowledge.WitnessVariable;
import de.upb.crypto.zeroknowledge.zeroKnowledge.ZeroKnowledgePackage;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ZeroKnowledgeSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ZeroKnowledgeGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ZeroKnowledgePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ZeroKnowledgePackage.ARGUMENT:
				sequence_Argument(context, (Argument) semanticObject); 
				return; 
			case ZeroKnowledgePackage.BRACKETS:
				sequence_Brackets(context, (Brackets) semanticObject); 
				return; 
			case ZeroKnowledgePackage.COMPARISON:
				sequence_Comparison(context, (Comparison) semanticObject); 
				return; 
			case ZeroKnowledgePackage.CONJUNCTION:
				sequence_Conjunction(context, (Conjunction) semanticObject); 
				return; 
			case ZeroKnowledgePackage.DISJUNCTION:
				sequence_Disjunction(context, (Disjunction) semanticObject); 
				return; 
			case ZeroKnowledgePackage.FUNCTION_CALL:
				sequence_FunctionCall(context, (FunctionCall) semanticObject); 
				return; 
			case ZeroKnowledgePackage.FUNCTION_DEFINITION:
				sequence_FunctionDefinition(context, (FunctionDefinition) semanticObject); 
				return; 
			case ZeroKnowledgePackage.LOCAL_VARIABLE:
				sequence_LocalVariable(context, (LocalVariable) semanticObject); 
				return; 
			case ZeroKnowledgePackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case ZeroKnowledgePackage.NEGATIVE:
				sequence_Negative(context, (Negative) semanticObject); 
				return; 
			case ZeroKnowledgePackage.NUMBER_LITERAL:
				sequence_NumberLiteral(context, (NumberLiteral) semanticObject); 
				return; 
			case ZeroKnowledgePackage.PARAMETER:
				sequence_Parameter(context, (de.upb.crypto.zeroknowledge.zeroKnowledge.Parameter) semanticObject); 
				return; 
			case ZeroKnowledgePackage.PARAMETER_LIST:
				sequence_ParameterList(context, (ParameterList) semanticObject); 
				return; 
			case ZeroKnowledgePackage.POWER:
				sequence_Power(context, (Power) semanticObject); 
				return; 
			case ZeroKnowledgePackage.PRODUCT:
				sequence_Product(context, (Product) semanticObject); 
				return; 
			case ZeroKnowledgePackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case ZeroKnowledgePackage.SUM:
				sequence_Sum(context, (Sum) semanticObject); 
				return; 
			case ZeroKnowledgePackage.TUPLE:
				sequence_Tuple(context, (Tuple) semanticObject); 
				return; 
			case ZeroKnowledgePackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case ZeroKnowledgePackage.WITNESS:
				sequence_Witness(context, (Witness) semanticObject); 
				return; 
			case ZeroKnowledgePackage.WITNESS_LIST:
				sequence_WitnessList(context, (WitnessList) semanticObject); 
				return; 
			case ZeroKnowledgePackage.WITNESS_VARIABLE:
				sequence_WitnessVariable(context, (WitnessVariable) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Argument returns Argument
	 *
	 * Constraint:
	 *     expression=Conjunction
	 */
	protected void sequence_Argument(ISerializationContext context, Argument semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ZeroKnowledgePackage.Literals.ARGUMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ZeroKnowledgePackage.Literals.ARGUMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArgumentAccess().getExpressionConjunctionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Brackets
	 *     Conjunction returns Brackets
	 *     Conjunction.Conjunction_1_0 returns Brackets
	 *     Disjunction returns Brackets
	 *     Disjunction.Disjunction_1_0 returns Brackets
	 *     Comparison returns Brackets
	 *     Comparison.Comparison_1_0_0_0 returns Brackets
	 *     Comparison.Comparison_1_0_1_0 returns Brackets
	 *     Comparison.Comparison_1_0_2_0 returns Brackets
	 *     Comparison.Comparison_1_0_3_0 returns Brackets
	 *     Comparison.Comparison_1_0_4_0 returns Brackets
	 *     Comparison.Comparison_1_0_5_0 returns Brackets
	 *     Sum returns Brackets
	 *     Sum.Sum_1_0_0_0 returns Brackets
	 *     Sum.Sum_1_0_1_0 returns Brackets
	 *     Product returns Brackets
	 *     Product.Product_1_0_0_0 returns Brackets
	 *     Product.Product_1_0_1_0 returns Brackets
	 *     Power returns Brackets
	 *     Power.Power_1_0 returns Brackets
	 *     Construct returns Brackets
	 *     Negative returns Brackets
	 *     Value returns Brackets
	 *     Brackets returns Brackets
	 *
	 * Constraint:
	 *     content=Expression
	 */
	protected void sequence_Brackets(ISerializationContext context, Brackets semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ZeroKnowledgePackage.Literals.BRACKETS__CONTENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ZeroKnowledgePackage.Literals.BRACKETS__CONTENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBracketsAccess().getContentExpressionParserRuleCall_1_0(), semanticObject.getContent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Comparison
	 *     Conjunction returns Comparison
	 *     Conjunction.Conjunction_1_0 returns Comparison
	 *     Disjunction returns Comparison
	 *     Disjunction.Disjunction_1_0 returns Comparison
	 *     Comparison returns Comparison
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (left=Comparison_Comparison_1_0_0_0 operation='!=') | 
	 *             (left=Comparison_Comparison_1_0_1_0 operation='=') | 
	 *             (left=Comparison_Comparison_1_0_2_0 operation='>=') | 
	 *             (left=Comparison_Comparison_1_0_3_0 operation='<=') | 
	 *             (left=Comparison_Comparison_1_0_4_0 operation='>') | 
	 *             (left=Comparison_Comparison_1_0_5_0 operation='<')
	 *         ) 
	 *         right=Sum
	 *     )
	 */
	protected void sequence_Comparison(ISerializationContext context, Comparison semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Conjunction
	 *     Conjunction returns Conjunction
	 *     Conjunction.Conjunction_1_0 returns Conjunction
	 *
	 * Constraint:
	 *     (left=Conjunction_Conjunction_1_0 operation='&' right=Disjunction)
	 */
	protected void sequence_Conjunction(ISerializationContext context, Conjunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ZeroKnowledgePackage.Literals.CONJUNCTION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ZeroKnowledgePackage.Literals.CONJUNCTION__LEFT));
			if (transientValues.isValueTransient(semanticObject, ZeroKnowledgePackage.Literals.CONJUNCTION__OPERATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ZeroKnowledgePackage.Literals.CONJUNCTION__OPERATION));
			if (transientValues.isValueTransient(semanticObject, ZeroKnowledgePackage.Literals.CONJUNCTION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ZeroKnowledgePackage.Literals.CONJUNCTION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConjunctionAccess().getConjunctionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getConjunctionAccess().getOperationAmpersandKeyword_1_1_0(), semanticObject.getOperation());
		feeder.accept(grammarAccess.getConjunctionAccess().getRightDisjunctionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Disjunction
	 *     Conjunction returns Disjunction
	 *     Conjunction.Conjunction_1_0 returns Disjunction
	 *     Disjunction returns Disjunction
	 *     Disjunction.Disjunction_1_0 returns Disjunction
	 *
	 * Constraint:
	 *     (left=Disjunction_Disjunction_1_0 operation='|' right=Comparison)
	 */
	protected void sequence_Disjunction(ISerializationContext context, Disjunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ZeroKnowledgePackage.Literals.DISJUNCTION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ZeroKnowledgePackage.Literals.DISJUNCTION__LEFT));
			if (transientValues.isValueTransient(semanticObject, ZeroKnowledgePackage.Literals.DISJUNCTION__OPERATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ZeroKnowledgePackage.Literals.DISJUNCTION__OPERATION));
			if (transientValues.isValueTransient(semanticObject, ZeroKnowledgePackage.Literals.DISJUNCTION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ZeroKnowledgePackage.Literals.DISJUNCTION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDisjunctionAccess().getDisjunctionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getDisjunctionAccess().getOperationVerticalLineKeyword_1_1_0(), semanticObject.getOperation());
		feeder.accept(grammarAccess.getDisjunctionAccess().getRightComparisonParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns FunctionCall
	 *     Conjunction returns FunctionCall
	 *     Conjunction.Conjunction_1_0 returns FunctionCall
	 *     Disjunction returns FunctionCall
	 *     Disjunction.Disjunction_1_0 returns FunctionCall
	 *     Comparison returns FunctionCall
	 *     Comparison.Comparison_1_0_0_0 returns FunctionCall
	 *     Comparison.Comparison_1_0_1_0 returns FunctionCall
	 *     Comparison.Comparison_1_0_2_0 returns FunctionCall
	 *     Comparison.Comparison_1_0_3_0 returns FunctionCall
	 *     Comparison.Comparison_1_0_4_0 returns FunctionCall
	 *     Comparison.Comparison_1_0_5_0 returns FunctionCall
	 *     Sum returns FunctionCall
	 *     Sum.Sum_1_0_0_0 returns FunctionCall
	 *     Sum.Sum_1_0_1_0 returns FunctionCall
	 *     Product returns FunctionCall
	 *     Product.Product_1_0_0_0 returns FunctionCall
	 *     Product.Product_1_0_1_0 returns FunctionCall
	 *     Power returns FunctionCall
	 *     Power.Power_1_0 returns FunctionCall
	 *     Construct returns FunctionCall
	 *     Negative returns FunctionCall
	 *     Value returns FunctionCall
	 *     FunctionCall returns FunctionCall
	 *
	 * Constraint:
	 *     (name=IDENTIFIER (arguments+=Argument arguments+=Argument*)?)
	 */
	protected void sequence_FunctionCall(ISerializationContext context, FunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionDefinition returns FunctionDefinition
	 *
	 * Constraint:
	 *     (name=IDENTIFIER parameterList=ParameterList body=Expression)
	 */
	protected void sequence_FunctionDefinition(ISerializationContext context, FunctionDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ZeroKnowledgePackage.Literals.FUNCTION_DEFINITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ZeroKnowledgePackage.Literals.FUNCTION_DEFINITION__NAME));
			if (transientValues.isValueTransient(semanticObject, ZeroKnowledgePackage.Literals.FUNCTION_DEFINITION__PARAMETER_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ZeroKnowledgePackage.Literals.FUNCTION_DEFINITION__PARAMETER_LIST));
			if (transientValues.isValueTransient(semanticObject, ZeroKnowledgePackage.Literals.FUNCTION_DEFINITION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ZeroKnowledgePackage.Literals.FUNCTION_DEFINITION__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionDefinitionAccess().getNameIDENTIFIERTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFunctionDefinitionAccess().getParameterListParameterListParserRuleCall_1_0(), semanticObject.getParameterList());
		feeder.accept(grammarAccess.getFunctionDefinitionAccess().getBodyExpressionParserRuleCall_3_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LocalVariable returns LocalVariable
	 *
	 * Constraint:
	 *     (name=IDENTIFIER function=IDENTIFIER)
	 */
	protected void sequence_LocalVariable(ISerializationContext context, LocalVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ZeroKnowledgePackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ZeroKnowledgePackage.Literals.VARIABLE__NAME));
			if (transientValues.isValueTransient(semanticObject, ZeroKnowledgePackage.Literals.LOCAL_VARIABLE__FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ZeroKnowledgePackage.Literals.LOCAL_VARIABLE__FUNCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLocalVariableAccess().getNameIDENTIFIERTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLocalVariableAccess().getFunctionIDENTIFIERTerminalRuleCall_2_0(), semanticObject.getFunction());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (functions+=FunctionDefinition* witnessList=WitnessList proof=Expression)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Negative
	 *     Conjunction returns Negative
	 *     Conjunction.Conjunction_1_0 returns Negative
	 *     Disjunction returns Negative
	 *     Disjunction.Disjunction_1_0 returns Negative
	 *     Comparison returns Negative
	 *     Comparison.Comparison_1_0_0_0 returns Negative
	 *     Comparison.Comparison_1_0_1_0 returns Negative
	 *     Comparison.Comparison_1_0_2_0 returns Negative
	 *     Comparison.Comparison_1_0_3_0 returns Negative
	 *     Comparison.Comparison_1_0_4_0 returns Negative
	 *     Comparison.Comparison_1_0_5_0 returns Negative
	 *     Sum returns Negative
	 *     Sum.Sum_1_0_0_0 returns Negative
	 *     Sum.Sum_1_0_1_0 returns Negative
	 *     Product returns Negative
	 *     Product.Product_1_0_0_0 returns Negative
	 *     Product.Product_1_0_1_0 returns Negative
	 *     Power returns Negative
	 *     Power.Power_1_0 returns Negative
	 *     Construct returns Negative
	 *     Negative returns Negative
	 *
	 * Constraint:
	 *     (operation='-' term=Value)
	 */
	protected void sequence_Negative(ISerializationContext context, Negative semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ZeroKnowledgePackage.Literals.NEGATIVE__OPERATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ZeroKnowledgePackage.Literals.NEGATIVE__OPERATION));
			if (transientValues.isValueTransient(semanticObject, ZeroKnowledgePackage.Literals.NEGATIVE__TERM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ZeroKnowledgePackage.Literals.NEGATIVE__TERM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNegativeAccess().getOperationHyphenMinusKeyword_0_1_0(), semanticObject.getOperation());
		feeder.accept(grammarAccess.getNegativeAccess().getTermValueParserRuleCall_0_2_0(), semanticObject.getTerm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NumberLiteral
	 *     Conjunction returns NumberLiteral
	 *     Conjunction.Conjunction_1_0 returns NumberLiteral
	 *     Disjunction returns NumberLiteral
	 *     Disjunction.Disjunction_1_0 returns NumberLiteral
	 *     Comparison returns NumberLiteral
	 *     Comparison.Comparison_1_0_0_0 returns NumberLiteral
	 *     Comparison.Comparison_1_0_1_0 returns NumberLiteral
	 *     Comparison.Comparison_1_0_2_0 returns NumberLiteral
	 *     Comparison.Comparison_1_0_3_0 returns NumberLiteral
	 *     Comparison.Comparison_1_0_4_0 returns NumberLiteral
	 *     Comparison.Comparison_1_0_5_0 returns NumberLiteral
	 *     Sum returns NumberLiteral
	 *     Sum.Sum_1_0_0_0 returns NumberLiteral
	 *     Sum.Sum_1_0_1_0 returns NumberLiteral
	 *     Product returns NumberLiteral
	 *     Product.Product_1_0_0_0 returns NumberLiteral
	 *     Product.Product_1_0_1_0 returns NumberLiteral
	 *     Power returns NumberLiteral
	 *     Power.Power_1_0 returns NumberLiteral
	 *     Construct returns NumberLiteral
	 *     Negative returns NumberLiteral
	 *     Value returns NumberLiteral
	 *     NumberLiteral returns NumberLiteral
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_NumberLiteral(ISerializationContext context, NumberLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ZeroKnowledgePackage.Literals.NUMBER_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ZeroKnowledgePackage.Literals.NUMBER_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberLiteralAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ParameterList returns ParameterList
	 *
	 * Constraint:
	 *     ((parameters+=Parameter parameters+=Parameter*)? symbol=')')
	 */
	protected void sequence_ParameterList(ISerializationContext context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     name=IDENTIFIER
	 */
	protected void sequence_Parameter(ISerializationContext context, de.upb.crypto.zeroknowledge.zeroKnowledge.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ZeroKnowledgePackage.Literals.PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ZeroKnowledgePackage.Literals.PARAMETER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getNameIDENTIFIERTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Power
	 *     Conjunction returns Power
	 *     Conjunction.Conjunction_1_0 returns Power
	 *     Disjunction returns Power
	 *     Disjunction.Disjunction_1_0 returns Power
	 *     Comparison returns Power
	 *     Comparison.Comparison_1_0_0_0 returns Power
	 *     Comparison.Comparison_1_0_1_0 returns Power
	 *     Comparison.Comparison_1_0_2_0 returns Power
	 *     Comparison.Comparison_1_0_3_0 returns Power
	 *     Comparison.Comparison_1_0_4_0 returns Power
	 *     Comparison.Comparison_1_0_5_0 returns Power
	 *     Sum returns Power
	 *     Sum.Sum_1_0_0_0 returns Power
	 *     Sum.Sum_1_0_1_0 returns Power
	 *     Product returns Power
	 *     Product.Product_1_0_0_0 returns Power
	 *     Product.Product_1_0_1_0 returns Power
	 *     Power returns Power
	 *
	 * Constraint:
	 *     (left=Power_Power_1_0 operation='^' right=Power)
	 */
	protected void sequence_Power(ISerializationContext context, Power semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ZeroKnowledgePackage.Literals.POWER__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ZeroKnowledgePackage.Literals.POWER__LEFT));
			if (transientValues.isValueTransient(semanticObject, ZeroKnowledgePackage.Literals.POWER__OPERATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ZeroKnowledgePackage.Literals.POWER__OPERATION));
			if (transientValues.isValueTransient(semanticObject, ZeroKnowledgePackage.Literals.POWER__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ZeroKnowledgePackage.Literals.POWER__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowerAccess().getPowerLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPowerAccess().getOperationCircumflexAccentKeyword_1_1_0(), semanticObject.getOperation());
		feeder.accept(grammarAccess.getPowerAccess().getRightPowerParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Product
	 *     Conjunction returns Product
	 *     Conjunction.Conjunction_1_0 returns Product
	 *     Disjunction returns Product
	 *     Disjunction.Disjunction_1_0 returns Product
	 *     Comparison returns Product
	 *     Comparison.Comparison_1_0_0_0 returns Product
	 *     Comparison.Comparison_1_0_1_0 returns Product
	 *     Comparison.Comparison_1_0_2_0 returns Product
	 *     Comparison.Comparison_1_0_3_0 returns Product
	 *     Comparison.Comparison_1_0_4_0 returns Product
	 *     Comparison.Comparison_1_0_5_0 returns Product
	 *     Sum returns Product
	 *     Sum.Sum_1_0_0_0 returns Product
	 *     Sum.Sum_1_0_1_0 returns Product
	 *     Product returns Product
	 *     Product.Product_1_0_0_0 returns Product
	 *     Product.Product_1_0_1_0 returns Product
	 *
	 * Constraint:
	 *     (((left=Product_Product_1_0_0_0 operation='*') | (left=Product_Product_1_0_1_0 operation='/')) right=Power)
	 */
	protected void sequence_Product(ISerializationContext context, Product semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns StringLiteral
	 *     Conjunction returns StringLiteral
	 *     Conjunction.Conjunction_1_0 returns StringLiteral
	 *     Disjunction returns StringLiteral
	 *     Disjunction.Disjunction_1_0 returns StringLiteral
	 *     Comparison returns StringLiteral
	 *     Comparison.Comparison_1_0_0_0 returns StringLiteral
	 *     Comparison.Comparison_1_0_1_0 returns StringLiteral
	 *     Comparison.Comparison_1_0_2_0 returns StringLiteral
	 *     Comparison.Comparison_1_0_3_0 returns StringLiteral
	 *     Comparison.Comparison_1_0_4_0 returns StringLiteral
	 *     Comparison.Comparison_1_0_5_0 returns StringLiteral
	 *     Sum returns StringLiteral
	 *     Sum.Sum_1_0_0_0 returns StringLiteral
	 *     Sum.Sum_1_0_1_0 returns StringLiteral
	 *     Product returns StringLiteral
	 *     Product.Product_1_0_0_0 returns StringLiteral
	 *     Product.Product_1_0_1_0 returns StringLiteral
	 *     Power returns StringLiteral
	 *     Power.Power_1_0 returns StringLiteral
	 *     Construct returns StringLiteral
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING_LITERAL
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ZeroKnowledgePackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ZeroKnowledgePackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValueSTRING_LITERALTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Sum
	 *     Conjunction returns Sum
	 *     Conjunction.Conjunction_1_0 returns Sum
	 *     Disjunction returns Sum
	 *     Disjunction.Disjunction_1_0 returns Sum
	 *     Comparison returns Sum
	 *     Comparison.Comparison_1_0_0_0 returns Sum
	 *     Comparison.Comparison_1_0_1_0 returns Sum
	 *     Comparison.Comparison_1_0_2_0 returns Sum
	 *     Comparison.Comparison_1_0_3_0 returns Sum
	 *     Comparison.Comparison_1_0_4_0 returns Sum
	 *     Comparison.Comparison_1_0_5_0 returns Sum
	 *     Sum returns Sum
	 *     Sum.Sum_1_0_0_0 returns Sum
	 *     Sum.Sum_1_0_1_0 returns Sum
	 *
	 * Constraint:
	 *     (((left=Sum_Sum_1_0_0_0 operation='+') | (left=Sum_Sum_1_0_1_0 operation='-')) right=Product)
	 */
	protected void sequence_Sum(ISerializationContext context, Sum semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Tuple
	 *     Conjunction returns Tuple
	 *     Conjunction.Conjunction_1_0 returns Tuple
	 *     Disjunction returns Tuple
	 *     Disjunction.Disjunction_1_0 returns Tuple
	 *     Comparison returns Tuple
	 *     Comparison.Comparison_1_0_0_0 returns Tuple
	 *     Comparison.Comparison_1_0_1_0 returns Tuple
	 *     Comparison.Comparison_1_0_2_0 returns Tuple
	 *     Comparison.Comparison_1_0_3_0 returns Tuple
	 *     Comparison.Comparison_1_0_4_0 returns Tuple
	 *     Comparison.Comparison_1_0_5_0 returns Tuple
	 *     Sum returns Tuple
	 *     Sum.Sum_1_0_0_0 returns Tuple
	 *     Sum.Sum_1_0_1_0 returns Tuple
	 *     Product returns Tuple
	 *     Product.Product_1_0_0_0 returns Tuple
	 *     Product.Product_1_0_1_0 returns Tuple
	 *     Power returns Tuple
	 *     Power.Power_1_0 returns Tuple
	 *     Construct returns Tuple
	 *     Tuple returns Tuple
	 *
	 * Constraint:
	 *     (elements+=Conjunction elements+=Conjunction elements+=Conjunction*)
	 */
	protected void sequence_Tuple(ISerializationContext context, Tuple semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Variable
	 *     Conjunction returns Variable
	 *     Conjunction.Conjunction_1_0 returns Variable
	 *     Disjunction returns Variable
	 *     Disjunction.Disjunction_1_0 returns Variable
	 *     Comparison returns Variable
	 *     Comparison.Comparison_1_0_0_0 returns Variable
	 *     Comparison.Comparison_1_0_1_0 returns Variable
	 *     Comparison.Comparison_1_0_2_0 returns Variable
	 *     Comparison.Comparison_1_0_3_0 returns Variable
	 *     Comparison.Comparison_1_0_4_0 returns Variable
	 *     Comparison.Comparison_1_0_5_0 returns Variable
	 *     Sum returns Variable
	 *     Sum.Sum_1_0_0_0 returns Variable
	 *     Sum.Sum_1_0_1_0 returns Variable
	 *     Product returns Variable
	 *     Product.Product_1_0_0_0 returns Variable
	 *     Product.Product_1_0_1_0 returns Variable
	 *     Power returns Variable
	 *     Power.Power_1_0 returns Variable
	 *     Construct returns Variable
	 *     Negative returns Variable
	 *     Value returns Variable
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     name=IDENTIFIER
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ZeroKnowledgePackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ZeroKnowledgePackage.Literals.VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getNameIDENTIFIERTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     WitnessList returns WitnessList
	 *
	 * Constraint:
	 *     ((witnesses+=Witness witnesses+=Witness*)? symbol=')')
	 */
	protected void sequence_WitnessList(ISerializationContext context, WitnessList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WitnessVariable returns WitnessVariable
	 *
	 * Constraint:
	 *     name=IDENTIFIER
	 */
	protected void sequence_WitnessVariable(ISerializationContext context, WitnessVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ZeroKnowledgePackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ZeroKnowledgePackage.Literals.VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWitnessVariableAccess().getNameIDENTIFIERTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Witness returns Witness
	 *
	 * Constraint:
	 *     name=IDENTIFIER
	 */
	protected void sequence_Witness(ISerializationContext context, Witness semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ZeroKnowledgePackage.Literals.WITNESS__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ZeroKnowledgePackage.Literals.WITNESS__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWitnessAccess().getNameIDENTIFIERTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
