/**
 * generated by Xtext 2.17.0
 */
package de.upb.crypto.zeroknowledge.generator;

import com.google.common.base.Objects;
import de.upb.crypto.zeroknowledge.helpers.BranchState;
import de.upb.crypto.zeroknowledge.helpers.ModelHelper;
import de.upb.crypto.zeroknowledge.helpers.ModelMap;
import de.upb.crypto.zeroknowledge.helpers.ModelPrinter;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Brackets;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Comparison;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Conjunction;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Disjunction;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Expression;
import de.upb.crypto.zeroknowledge.zeroKnowledge.FunctionCall;
import de.upb.crypto.zeroknowledge.zeroKnowledge.FunctionDefinition;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Model;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Negative;
import de.upb.crypto.zeroknowledge.zeroKnowledge.NumberLiteral;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Parameter;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Power;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Product;
import de.upb.crypto.zeroknowledge.zeroKnowledge.StringLiteral;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Sum;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Tuple;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Variable;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class ZeroKnowledgeGenerator extends AbstractGenerator {
  private Set<String> variables;
  
  private Set<String> literals;
  
  private StringBuilder codeBuilder;
  
  private StringBuilder importBuilder;
  
  private StringBuilder functionBuilder;
  
  private StringBuilder exponentVariableBuilder;
  
  private StringBuilder groupVariableBuilder;
  
  private StringBuilder literalBuilder;
  
  private String OPERATOR_EQUAL = "=";
  
  private String OPERATOR_INEQUAL = "!=";
  
  private String OPERATOR_LESS = "<";
  
  private String OPERATOR_GREATER = ">";
  
  private String OPERATOR_LESSEQUAL = "<=";
  
  private String OPERATOR_GREATEREQUAL = ">=";
  
  private String NEWLINE = "\n";
  
  private String INDENT = "  ";
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    HashSet<String> _hashSet = new HashSet<String>();
    this.variables = _hashSet;
    HashSet<String> _hashSet_1 = new HashSet<String>();
    this.literals = _hashSet_1;
    StringBuilder _stringBuilder = new StringBuilder();
    this.codeBuilder = _stringBuilder;
    StringBuilder _stringBuilder_1 = new StringBuilder();
    this.importBuilder = _stringBuilder_1;
    StringBuilder _stringBuilder_2 = new StringBuilder();
    this.functionBuilder = _stringBuilder_2;
    StringBuilder _stringBuilder_3 = new StringBuilder();
    this.exponentVariableBuilder = _stringBuilder_3;
    StringBuilder _stringBuilder_4 = new StringBuilder();
    this.groupVariableBuilder = _stringBuilder_4;
    StringBuilder _stringBuilder_5 = new StringBuilder();
    this.literalBuilder = _stringBuilder_5;
    EObject _next = resource.getContents().iterator().next();
    final Model model = ((Model) _next);
    final boolean inline = false;
    if (inline) {
      ModelHelper.inlineFunctions(model);
    }
    ModelHelper.normalizeNegatives(model);
    ModelPrinter.print(model);
    this.generateImports();
    BranchState _branchState = new BranchState();
    this.generateFunctions(model, _branchState);
    BranchState _branchState_1 = new BranchState();
    final String code = this.generateCode(model, _branchState_1);
    this.codeBuilder.append(this.importBuilder);
    this.codeBuilder.append(this.NEWLINE);
    this.codeBuilder.append(this.functionBuilder);
    this.codeBuilder.append(this.NEWLINE);
    this.codeBuilder.append(this.literalBuilder);
    this.codeBuilder.append(this.NEWLINE);
    this.codeBuilder.append(this.exponentVariableBuilder);
    this.codeBuilder.append(this.NEWLINE);
    this.codeBuilder.append(this.groupVariableBuilder);
    this.codeBuilder.append(this.NEWLINE);
    this.codeBuilder.append(code);
    System.out.println(this.codeBuilder.toString());
    boolean _isCanceled = context.getCancelIndicator().isCanceled();
    if (_isCanceled) {
      return;
    }
    fsa.generateFile("first.java", this.codeBuilder.toString());
  }
  
  public void generateImports() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("import de.upb.crypto.math.expressions.*;");
    _builder.newLine();
    this.importBuilder.append(_builder);
  }
  
  public void generateFunctions(final Model model, final BranchState state) {
    EList<FunctionDefinition> _functions = model.getFunctions();
    for (final FunctionDefinition function : _functions) {
      {
        final Map<String, Boolean> mapping = new HashMap<String, Boolean>();
        final Procedure1<EObject> _function = (EObject node) -> {
          if ((node instanceof Sum)) {
            final Procedure1<EObject> _function_1 = (EObject child) -> {
              if ((child instanceof Variable)) {
                final String name = ((Variable)child).getName();
                boolean _containsKey = mapping.containsKey(name);
                boolean _not = (!_containsKey);
                if (_not) {
                  mapping.put(name, Boolean.valueOf(true));
                }
              }
            };
            ModelMap.postorder(node, _function_1);
          } else {
            if ((node instanceof Power)) {
              final Procedure1<EObject> _function_2 = (EObject child) -> {
                if ((child instanceof Variable)) {
                  final String name = ((Variable)child).getName();
                  boolean _containsKey = mapping.containsKey(name);
                  boolean _not = (!_containsKey);
                  if (_not) {
                    mapping.put(name, Boolean.valueOf(true));
                  }
                }
              };
              ModelMap.postorder(((Power)node).getRight(), _function_2);
            }
          }
        };
        ModelMap.preorder(function.getBody(), _function);
        final Procedure1<EObject> _function_1 = (EObject node) -> {
          if ((node instanceof Variable)) {
            final String name = ((Variable)node).getName();
            boolean _containsKey = mapping.containsKey(name);
            boolean _not = (!_containsKey);
            if (_not) {
              mapping.put(name, Boolean.valueOf(false));
            }
          }
        };
        ModelMap.postorder(function.getBody(), _function_1);
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("private static ");
        String _name = function.getName();
        _builder.append(_name);
        _builder.append("(");
        {
          EList<Parameter> _parameters = function.getParameterList().getParameters();
          boolean _hasElements = false;
          for(final Parameter parameter : _parameters) {
            if (!_hasElements) {
              _hasElements = true;
            } else {
              _builder.appendImmediate(", ", "");
            }
            {
              if (((Boolean.valueOf(mapping.containsKey(parameter.getName())) == Boolean.valueOf(true)) && (mapping.get(parameter.getName())).booleanValue())) {
                _builder.append("ExponentVariableExpr");
              } else {
                _builder.append("GroupVariablExpr");
              }
            }
            _builder.append(" ");
            String _name_1 = parameter.getName();
            _builder.append(_name_1);
          }
        }
        _builder.append(") {");
        _builder.newLineIfNotEmpty();
        _builder.append("  ");
        String _generateCode = this.generateCode(function.getBody(), state);
        _builder.append(_generateCode, "  ");
        _builder.append(";");
        _builder.newLineIfNotEmpty();
        _builder.append("}");
        _builder.newLine();
        this.functionBuilder.append(_builder);
      }
    }
  }
  
  protected String _generateCode(final Model node, final BranchState state) {
    StringConcatenation _builder = new StringConcatenation();
    String _generateCode = this.generateCode(node.getProof(), state);
    _builder.append(_generateCode);
    _builder.append(";");
    return _builder.toString();
  }
  
  protected String _generateCode(final Conjunction node, final BranchState state) {
    final String left = this.generateCode(node.getLeft(), state);
    final String right = this.generateCode(node.getRight(), state);
    StringConcatenation _builder = new StringConcatenation();
    _builder.append(left);
    _builder.newLineIfNotEmpty();
    _builder.append(".and(");
    _builder.append(right);
    _builder.append(")");
    return _builder.toString();
  }
  
  protected String _generateCode(final Disjunction node, final BranchState state) {
    final String left = this.generateCode(node.getLeft(), state);
    final String right = this.generateCode(node.getRight(), state);
    StringConcatenation _builder = new StringConcatenation();
    _builder.append(left);
    _builder.append(".or(");
    _builder.append(right);
    _builder.append(")");
    return _builder.toString();
  }
  
  protected String _generateCode(final Comparison node, final BranchState state) {
    final String left = this.generateCode(node.getLeft(), state);
    final String right = this.generateCode(node.getRight(), state);
    String operator = null;
    String _operation = node.getOperation();
    boolean _matched = false;
    if (Objects.equal(_operation, this.OPERATOR_EQUAL)) {
      _matched=true;
      operator = "equals";
    }
    if (!_matched) {
      if (Objects.equal(_operation, this.OPERATOR_INEQUAL)) {
        _matched=true;
        operator = "notequals";
      }
    }
    if (!_matched) {
      if (Objects.equal(_operation, this.OPERATOR_LESS)) {
        _matched=true;
        operator = "lessthan";
      }
    }
    if (!_matched) {
      if (Objects.equal(_operation, this.OPERATOR_GREATER)) {
        _matched=true;
        operator = "greaterthan";
      }
    }
    if (!_matched) {
      if (Objects.equal(_operation, this.OPERATOR_LESSEQUAL)) {
        _matched=true;
        operator = "lessthanequal";
      }
    }
    if (!_matched) {
      if (Objects.equal(_operation, this.OPERATOR_GREATEREQUAL)) {
        _matched=true;
        operator = "greaterthanequal";
      }
    }
    StringConcatenation _builder = new StringConcatenation();
    _builder.append(left);
    _builder.append(".");
    _builder.append(operator);
    _builder.append("(");
    _builder.append(right);
    _builder.append(")");
    return _builder.toString();
  }
  
  protected String _generateCode(final Sum node, final BranchState state) {
    final BranchState newState = new BranchState(state);
    final String left = this.generateCode(node.getLeft(), newState);
    final String right = this.generateCode(node.getRight(), newState);
    StringConcatenation _builder = new StringConcatenation();
    _builder.append(left);
    _builder.append(".add(");
    _builder.append(right);
    _builder.append(")");
    return _builder.toString();
  }
  
  protected String _generateCode(final Product node, final BranchState state) {
    final String left = this.generateCode(node.getLeft(), state);
    final String right = this.generateCode(node.getRight(), state);
    boolean _hasSumOrPowerAncestor = ModelHelper.hasSumOrPowerAncestor(node);
    if (_hasSumOrPowerAncestor) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append(left);
      _builder.append(".mul(");
      _builder.append(right);
      _builder.append(")");
      return _builder.toString();
    } else {
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append(left);
      _builder_1.append(".op(");
      _builder_1.append(right);
      _builder_1.append(")");
      return _builder_1.toString();
    }
  }
  
  protected String _generateCode(final Power node, final BranchState state) {
    final String left = this.generateCode(node.getLeft(), state);
    final String right = this.generateCode(node.getRight(), state);
    StringConcatenation _builder = new StringConcatenation();
    _builder.append(left);
    _builder.append(".pow(");
    _builder.append(right);
    _builder.append(")");
    return _builder.toString();
  }
  
  protected String _generateCode(final StringLiteral node, final BranchState state) {
    StringConcatenation _builder = new StringConcatenation();
    String _value = node.getValue();
    _builder.append(_value);
    return _builder.toString();
  }
  
  protected String _generateCode(final Tuple node, final BranchState state) {
    StringConcatenation _builder = new StringConcatenation();
    {
      EList<Expression> _elements = node.getElements();
      boolean _hasElements = false;
      for(final Expression element : _elements) {
        if (!_hasElements) {
          _hasElements = true;
        } else {
          _builder.appendImmediate(", ", "");
        }
        String _generateCode = this.generateCode(element, state);
        _builder.append(_generateCode);
      }
    }
    return _builder.toString();
  }
  
  protected String _generateCode(final Negative node, final BranchState state) {
    final String term = this.generateCode(node.getTerm(), state);
    StringConcatenation _builder = new StringConcatenation();
    _builder.append(term);
    _builder.append(".neg()");
    return _builder.toString();
  }
  
  protected String _generateCode(final FunctionCall node, final BranchState state) {
    final String name = ModelHelper.convertToJavaName(node.getName());
    StringConcatenation _builder = new StringConcatenation();
    _builder.append(name);
    _builder.append("(");
    {
      EList<Expression> _arguments = node.getArguments();
      boolean _hasElements = false;
      for(final Expression argument : _arguments) {
        if (!_hasElements) {
          _hasElements = true;
        } else {
          _builder.appendImmediate(",", "");
        }
        _builder.append("generateCode(argument)");
      }
    }
    _builder.append(")");
    return _builder.toString();
  }
  
  protected String _generateCode(final Variable node, final BranchState state) {
    final String name = ModelHelper.convertToJavaName(node.getName());
    if (true) {
      boolean _contains = this.variables.contains(name);
      boolean _not = (!_contains);
      if (_not) {
        this.variables.add(name);
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("ExponentVariableExpr ");
        _builder.append(name);
        _builder.append(" = new ExponentVariableExpr(");
        _builder.append(name);
        _builder.append(");");
        _builder.newLineIfNotEmpty();
        this.exponentVariableBuilder.append(_builder);
      }
    } else {
      boolean _contains_1 = this.variables.contains(name);
      boolean _not_1 = (!_contains_1);
      if (_not_1) {
        this.variables.add(name);
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("GroupVariableExpr ");
        _builder_1.append(name);
        _builder_1.append(" = new GroupVariableExpr(\"");
        _builder_1.append(name);
        _builder_1.append("\");");
        _builder_1.newLineIfNotEmpty();
        this.groupVariableBuilder.append(_builder_1);
      }
    }
    this.variables.add(name);
    return name;
  }
  
  protected String _generateCode(final NumberLiteral node, final BranchState state) {
    int _value = node.getValue();
    final String name = ("val_" + Integer.valueOf(_value));
    boolean _contains = this.literals.contains(name);
    boolean _not = (!_contains);
    if (_not) {
      this.literals.add(name);
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("ExponentLiteralExpr ");
      _builder.append(name);
      _builder.append(" = new ExponentLiteralExpr(");
      int _value_1 = node.getValue();
      _builder.append(_value_1);
      _builder.append(");");
      _builder.newLineIfNotEmpty();
      this.literalBuilder.append(_builder);
    }
    return name;
  }
  
  protected String _generateCode(final Brackets node, final BranchState state) {
    return this.generateCode(node.getContent(), state);
  }
  
  public String generateCode(final EObject node, final BranchState state) {
    if (node instanceof Brackets) {
      return _generateCode((Brackets)node, state);
    } else if (node instanceof Comparison) {
      return _generateCode((Comparison)node, state);
    } else if (node instanceof Conjunction) {
      return _generateCode((Conjunction)node, state);
    } else if (node instanceof Disjunction) {
      return _generateCode((Disjunction)node, state);
    } else if (node instanceof FunctionCall) {
      return _generateCode((FunctionCall)node, state);
    } else if (node instanceof Negative) {
      return _generateCode((Negative)node, state);
    } else if (node instanceof NumberLiteral) {
      return _generateCode((NumberLiteral)node, state);
    } else if (node instanceof Power) {
      return _generateCode((Power)node, state);
    } else if (node instanceof Product) {
      return _generateCode((Product)node, state);
    } else if (node instanceof StringLiteral) {
      return _generateCode((StringLiteral)node, state);
    } else if (node instanceof Sum) {
      return _generateCode((Sum)node, state);
    } else if (node instanceof Tuple) {
      return _generateCode((Tuple)node, state);
    } else if (node instanceof Variable) {
      return _generateCode((Variable)node, state);
    } else if (node instanceof Model) {
      return _generateCode((Model)node, state);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(node, state).toString());
    }
  }
}
