/**
 * generated by Xtext 2.17.0
 */
package de.upb.crypto.zeroknowledge.validation;

import com.google.common.base.Objects;
import de.upb.crypto.zeroknowledge.helpers.BranchState;
import de.upb.crypto.zeroknowledge.helpers.FunctionSignature;
import de.upb.crypto.zeroknowledge.helpers.ModelHelper;
import de.upb.crypto.zeroknowledge.helpers.ModelMap;
import de.upb.crypto.zeroknowledge.helpers.PredefinedFunctionsHelper;
import de.upb.crypto.zeroknowledge.helpers.Type;
import de.upb.crypto.zeroknowledge.validation.AbstractZeroKnowledgeValidator;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Brackets;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Comparison;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Conjunction;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Disjunction;
import de.upb.crypto.zeroknowledge.zeroKnowledge.FunctionCall;
import de.upb.crypto.zeroknowledge.zeroKnowledge.FunctionDefinition;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Model;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Negative;
import de.upb.crypto.zeroknowledge.zeroKnowledge.NumberLiteral;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Parameter;
import de.upb.crypto.zeroknowledge.zeroKnowledge.ParameterList;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Power;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Product;
import de.upb.crypto.zeroknowledge.zeroKnowledge.StringLiteral;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Sum;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Tuple;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Variable;
import de.upb.crypto.zeroknowledge.zeroKnowledge.Witness;
import de.upb.crypto.zeroknowledge.zeroKnowledge.WitnessList;
import de.upb.crypto.zeroknowledge.zeroKnowledge.ZeroKnowledgePackage;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure2;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class ZeroKnowledgeValidator extends AbstractZeroKnowledgeValidator {
  private Map<EObject, Type> nodeType;
  
  private Map<String, FunctionSignature> predefinedFunctions = PredefinedFunctionsHelper.getAllPredefinedFunctions();
  
  private Map<String, FunctionSignature> userFunctions;
  
  private HashSet<String> witnessNames;
  
  @Check
  public void checkModel(final Model model) {
    this.userFunctions = this.fetchUserFunctions(model);
    this.witnessNames = this.fetchWitnessNames(model);
    BranchState _branchState = new BranchState();
    final Procedure2<EObject, BranchState> _function = (EObject node, BranchState state) -> {
      this.checkNode(node, state);
    };
    ModelMap.preorderWithState(model, _branchState, _function);
  }
  
  public HashMap<String, FunctionSignature> fetchUserFunctions(final Model model) {
    final HashMap<String, FunctionSignature> functions = new HashMap<String, FunctionSignature>();
    EList<FunctionDefinition> _functions = model.getFunctions();
    for (final FunctionDefinition function : _functions) {
      String _name = function.getName();
      String _name_1 = function.getName();
      int _size = function.getParameterList().getParameters().size();
      FunctionSignature _functionSignature = new FunctionSignature(_name_1, "", _size);
      functions.put(_name, _functionSignature);
    }
    return functions;
  }
  
  public HashSet<String> fetchWitnessNames(final Model model) {
    final HashSet<String> witnesses = new HashSet<String>();
    EList<Witness> _witnesses = model.getWitnessList().getWitnesses();
    for (final Witness witness : _witnesses) {
      witnesses.add(witness.getName());
    }
    return witnesses;
  }
  
  protected void _checkNode(final Model model, final BranchState state) {
    this.checkFunctionNamesAreUnique(model);
    System.out.println("model");
    return;
  }
  
  protected void _checkNode(final FunctionDefinition function, final BranchState state) {
    this.checkFunctionNameFormat(function);
    this.checkFunctionNameIsNotPredefined(function);
    this.checkFunctionIsCalled(function);
    this.checkFunctionParametersAreUsed(function);
    System.out.println("function");
    return;
  }
  
  protected void _checkNode(final ParameterList parameterList, final BranchState state) {
    this.checkFunctionParameterNamesAreUnique(parameterList);
    System.out.println("parameterlist");
    return;
  }
  
  protected void _checkNode(final Parameter parameter, final BranchState state) {
    this.checkParameterNameFormat(parameter);
    System.out.println("parameter");
    return;
  }
  
  protected void _checkNode(final WitnessList witnessList, final BranchState state) {
    this.checkWitnessListIsNonempty(witnessList);
    this.checkWitnessNamesAreUnique(witnessList);
    System.out.println("witnesslist");
    return;
  }
  
  protected void _checkNode(final Witness witness, final BranchState state) {
    this.checkWitnessNameFormat(witness);
    System.out.println("witness");
    return;
  }
  
  protected void _checkNode(final Conjunction conjunction, final BranchState state) {
    this.checkValidConjunctionPosition(conjunction, state);
    System.out.println("conjunction");
    return;
  }
  
  protected void _checkNode(final Disjunction disjunction, final BranchState state) {
    this.checkValidDisjunctionPosition(disjunction, state);
    System.out.println("disjunction");
    return;
  }
  
  protected void _checkNode(final Comparison comparison, final BranchState state) {
    this.checkValidComparisonPosition(comparison, state);
    System.out.println("comparison");
    return;
  }
  
  protected void _checkNode(final Sum sum, final BranchState state) {
    this.checkValidAlgebraicPosition(sum, state);
    System.out.println("sum");
    return;
  }
  
  protected void _checkNode(final Product product, final BranchState state) {
    this.checkValidAlgebraicPosition(product, state);
    System.out.println("product");
    return;
  }
  
  protected void _checkNode(final Power power, final BranchState state) {
    this.checkValidAlgebraicPosition(power, state);
    System.out.println("power");
    return;
  }
  
  protected void _checkNode(final StringLiteral stringLiteral, final BranchState state) {
    this.checkValidStringLiteralPosition(stringLiteral, state);
    System.out.println("string");
    return;
  }
  
  protected void _checkNode(final Tuple tuple, final BranchState state) {
    this.checkValidAlgebraicPosition(tuple, state);
    System.out.println("tuple");
    return;
  }
  
  protected void _checkNode(final Negative negative, final BranchState state) {
    this.checkValidAlgebraicPosition(negative, state);
    System.out.println("negative");
    return;
  }
  
  protected void _checkNode(final FunctionCall call, final BranchState state) {
    this.checkValidFunctionCall(call);
    this.checkFunctionHasNoUserFunctionCalls(call, state);
    this.checkValidAlgebraicPosition(call, state);
    return;
  }
  
  protected void _checkNode(final Variable variable, final BranchState state) {
    this.checkVariableNameFormat(variable);
    this.checkValidAlgebraicPosition(variable, state);
    System.out.println("variable");
    return;
  }
  
  protected void _checkNode(final NumberLiteral numberLiteral, final BranchState state) {
    this.checkValidAlgebraicPosition(numberLiteral, state);
    this.checkNumberLiteralIsExponentLiteral(numberLiteral, state);
    System.out.println("number");
    return;
  }
  
  protected void _checkNode(final Brackets brackets, final BranchState state) {
    this.checkValidAlgebraicPosition(brackets, state);
    System.out.println("brackets");
    return;
  }
  
  /**
   * Validate the format of identifier names
   */
  private void checkFunctionNameFormat(final FunctionDefinition function) {
    boolean _contains = function.getName().contains("_");
    if (_contains) {
      this.error("Function names can not contain underscores", function, 
        ZeroKnowledgePackage.Literals.FUNCTION_DEFINITION__NAME);
    }
    boolean _contains_1 = function.getName().contains("\'");
    if (_contains_1) {
      this.error("Function names can not contain single quotes", function, 
        ZeroKnowledgePackage.Literals.FUNCTION_DEFINITION__NAME);
    }
  }
  
  private void checkWitnessNameFormat(final Witness witness) {
    List<String> errors = this.nameFormatErrors(witness.getName(), "Witness");
    for (final Iterator<String> iterator = errors.iterator(); iterator.hasNext();) {
      this.error(iterator.next(), witness, ZeroKnowledgePackage.Literals.WITNESS__NAME);
    }
  }
  
  private void checkVariableNameFormat(final Variable variable) {
    List<String> errors = this.nameFormatErrors(variable.getName(), "Variable");
    for (final Iterator<String> iterator = errors.iterator(); iterator.hasNext();) {
      this.error(iterator.next(), variable, ZeroKnowledgePackage.Literals.VARIABLE__NAME);
    }
  }
  
  private void checkParameterNameFormat(final Parameter parameter) {
    List<String> name_errors = this.nameFormatErrors(parameter.getName(), "Parameter");
    for (final String name_error : name_errors) {
      {
        System.out.println("NAMEERRORFOUND");
        this.error(name_error, parameter, ZeroKnowledgePackage.Literals.PARAMETER__NAME);
      }
    }
  }
  
  private List<String> nameFormatErrors(final String identifier, final String type) {
    List<String> name_errors = new ArrayList<String>();
    int underscores = 0;
    for (int i = 0; (i < identifier.length()); i++) {
      char _charAt = identifier.charAt(i);
      boolean _equals = Objects.equal(Character.valueOf(_charAt), "_");
      if (_equals) {
        underscores++;
        if ((underscores > 1)) {
          name_errors.add((type + " name can contain at most 1 underscore"));
          i = identifier.length();
        }
      }
    }
    boolean quote = false;
    for (int i = 0; (i < identifier.length()); i++) {
      if ((quote && (!Objects.equal(Character.valueOf(identifier.charAt(i)), "\'")))) {
        name_errors.add((type + " name can only contain single quotes at the end of the name"));
      } else {
        char _charAt = identifier.charAt(i);
        boolean _equals = Objects.equal(Character.valueOf(_charAt), "\'");
        if (_equals) {
          quote = true;
        }
      }
    }
    int _length = identifier.length();
    int _minus = (_length - 1);
    char _charAt = identifier.charAt(_minus);
    boolean _equals = Objects.equal(Character.valueOf(_charAt), "_");
    if (_equals) {
      name_errors.add((type + " name can not end with an underscore"));
    }
    return name_errors;
  }
  
  /**
   * Validate the uniqueness of identifiers
   */
  private void checkFunctionNamesAreUnique(final Model model) {
    final HashSet<String> functions = new HashSet<String>();
    EList<FunctionDefinition> _functions = model.getFunctions();
    for (final FunctionDefinition function : _functions) {
      {
        final String name = function.getName();
        boolean _contains = functions.contains(name);
        if (_contains) {
          this.error("Function names must be unique", function, ZeroKnowledgePackage.Literals.FUNCTION_DEFINITION__NAME);
        } else {
          functions.add(name);
        }
      }
    }
  }
  
  private void checkFunctionNameIsNotPredefined(final FunctionDefinition function) {
    boolean _contains = FunctionSignature.getAllNames(this.predefinedFunctions).contains(function.getName());
    if (_contains) {
      this.error("Function name is already used by a predefined function", function, ZeroKnowledgePackage.Literals.FUNCTION_DEFINITION__NAME);
    }
  }
  
  private void checkWitnessNamesAreUnique(final WitnessList witnessList) {
    final Set<String> witnesses = new HashSet<String>();
    EList<Witness> _witnesses = witnessList.getWitnesses();
    for (final Witness witness : _witnesses) {
      {
        final String name = witness.getName();
        boolean _contains = witnesses.contains(name);
        if (_contains) {
          this.error("Witness names must be unique", witness, ZeroKnowledgePackage.Literals.WITNESS__NAME);
        } else {
          witnesses.add(name);
        }
      }
    }
  }
  
  private void checkFunctionParameterNamesAreUnique(final ParameterList parameterList) {
    final Set<String> parameters = new HashSet<String>();
    EList<Parameter> _parameters = parameterList.getParameters();
    for (final Parameter parameter : _parameters) {
      {
        final String name = parameter.getName();
        boolean _contains = parameters.contains(name);
        if (_contains) {
          this.error("Function parameters must be unique within a function\'s signature", parameterList, ZeroKnowledgePackage.Literals.FUNCTION_DEFINITION__PARAMETER_LIST);
        }
      }
    }
  }
  
  /**
   * Validate user function definitions
   */
  private void checkFunctionHasNoUserFunctionCalls(final FunctionCall call, final BranchState state) {
    boolean _hasFunctionDefinitionAncestor = state.hasFunctionDefinitionAncestor();
    if (_hasFunctionDefinitionAncestor) {
      this.error("Can not call user functions from within a user function", call, ZeroKnowledgePackage.Literals.FUNCTION_CALL__NAME);
    }
  }
  
  private void checkFunctionParametersAreUsed(final FunctionDefinition function) {
    EList<Parameter> _parameters = function.getParameterList().getParameters();
    for (final Parameter parameter : _parameters) {
      final Function1<EObject, Boolean> _function = (EObject node) -> {
        if ((node instanceof Variable)) {
          String _name = ((Variable)node).getName();
          String _name_1 = parameter.getName();
          boolean _equals = Objects.equal(_name, _name_1);
          if (_equals) {
            return true;
          }
        }
        return false;
      };
      boolean _postorderAny = ModelMap.postorderAny(function.getBody(), _function);
      boolean _not = (!_postorderAny);
      if (_not) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Parameter \'");
        String _name = parameter.getName();
        _builder.append(_name);
        _builder.append("\' must be used within the function definition");
        this.error(_builder.toString(), parameter, ZeroKnowledgePackage.Literals.PARAMETER__NAME);
      }
    }
  }
  
  private void checkFunctionIsCalled(final FunctionDefinition function) {
    final String function_name = function.getName();
    final Model root = ModelHelper.getRoot(function);
    final Function1<EObject, Boolean> _function = (EObject node) -> {
      if ((node instanceof FunctionCall)) {
        String _name = ((FunctionCall)node).getName();
        boolean _equals = Objects.equal(_name, function_name);
        if (_equals) {
          return true;
        }
      }
      return false;
    };
    boolean _postorderAny = ModelMap.postorderAny(root.getProof(), _function);
    boolean _not = (!_postorderAny);
    if (_not) {
      this.warning(
        "Function is never used in the proof expression, and will not be included in the generated Java code", function, 
        ZeroKnowledgePackage.Literals.FUNCTION_DEFINITION__NAME);
    }
  }
  
  /**
   * Validate the witness list
   */
  private void checkWitnessListIsNonempty(final WitnessList witnessList) {
    int _size = witnessList.getWitnesses().size();
    boolean _tripleEquals = (_size == 0);
    if (_tripleEquals) {
      this.error("The witness list must include at least one witness", witnessList, 
        ZeroKnowledgePackage.Literals.WITNESS_LIST__WITNESSES);
    }
  }
  
  /**
   * Validate function calls
   */
  private void checkValidFunctionCall(final FunctionCall call) {
    final String name = call.getName();
    FunctionSignature signature = this.userFunctions.get(name);
    if ((signature != null)) {
      int _parameterCount = signature.getParameterCount();
      int _size = call.getArguments().size();
      boolean _tripleNotEquals = (_parameterCount != _size);
      if (_tripleNotEquals) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("The number of arguments in the function call (");
        int _size_1 = call.getArguments().size();
        _builder.append(_size_1);
        _builder.append(") must match the number of parameters in the function definition (");
        int _parameterCount_1 = signature.getParameterCount();
        _builder.append(_parameterCount_1);
        _builder.append(")");
        this.error(_builder.toString(), call, 
          ZeroKnowledgePackage.Literals.FUNCTION_CALL__ARGUMENTS);
      }
      return;
    }
    signature = this.predefinedFunctions.get(name);
    if ((signature != null)) {
      int _parameterCount_2 = signature.getParameterCount();
      int _size_2 = call.getArguments().size();
      boolean _tripleNotEquals_1 = (_parameterCount_2 != _size_2);
      if (_tripleNotEquals_1) {
        this.error(
          "The number of arguments in the function call must match the number of parameters in the function definition", call, 
          ZeroKnowledgePackage.Literals.FUNCTION_CALL__ARGUMENTS);
      }
      return;
    }
    this.error("Function call references a function that does not exist", call, 
      ZeroKnowledgePackage.Literals.FUNCTION_CALL__NAME);
  }
  
  /**
   * Grammar structure
   */
  private void checkValidStringLiteralPosition(final StringLiteral stringLiteral, final BranchState state) {
    final EObject parent = state.getParent();
    if ((!(((parent instanceof Tuple) || (parent instanceof Comparison)) || (parent instanceof FunctionCall)))) {
      this.error("String literals must be contained within a tuple, a function call, or a comparison expression", stringLiteral, 
        ZeroKnowledgePackage.Literals.STRING_LITERAL__VALUE);
    }
  }
  
  private void checkValidConjunctionPosition(final Conjunction conjunction, final BranchState state) {
    boolean _isIllegallyNested = this.isIllegallyNested(conjunction, state);
    if (_isIllegallyNested) {
      this.error("Conjunctions can not be nested within algebraic or comparison expressions", conjunction, 
        ZeroKnowledgePackage.Literals.CONJUNCTION__OPERATION);
    }
  }
  
  private void checkValidDisjunctionPosition(final Disjunction disjunction, final BranchState state) {
    boolean _isIllegallyNested = this.isIllegallyNested(disjunction, state);
    if (_isIllegallyNested) {
      this.error("Disjunctions can not be nested within algebraic or comparison expressions", disjunction, 
        ZeroKnowledgePackage.Literals.DISJUNCTION__OPERATION);
    }
  }
  
  private void checkValidComparisonPosition(final Comparison comparison, final BranchState state) {
    boolean _isIllegallyNested = this.isIllegallyNested(comparison, state);
    if (_isIllegallyNested) {
      this.error("Comparisons can not be nested within algebraic expressions or other comparison expressions", comparison, 
        ZeroKnowledgePackage.Literals.COMPARISON__OPERATION);
    }
  }
  
  private boolean isIllegallyNested(final EObject node, final BranchState state) {
    final EObject parent = state.getParent();
    if (((((parent instanceof Model) || (parent instanceof FunctionDefinition)) || (parent instanceof Conjunction)) || (parent instanceof Disjunction))) {
      return true;
    }
    return false;
  }
  
  @Check
  public void checkAlgebraicPosition(final EObject node) {
    if (((!ModelHelper.isAlgebraic(node)) || (node instanceof FunctionCall))) {
      return;
    }
    boolean _hasComparisonBeforePropositional = this.hasComparisonBeforePropositional(node.eContainer());
    boolean _not = (!_hasComparisonBeforePropositional);
    if (_not) {
      this.error(
        "Algebraic expression must be nested within a comparison expression before being nested within a propositional expression", 
        null);
    }
  }
  
  private boolean hasComparisonBeforePropositional(final EObject node) {
    if (((node instanceof Conjunction) || (node instanceof Disjunction))) {
      return false;
    } else {
      if ((((node instanceof Comparison) || (node instanceof FunctionCall)) || (node instanceof Model))) {
        return true;
      }
    }
    return this.hasComparisonBeforePropositional(node.eContainer());
  }
  
  private void checkValidAlgebraicPosition(final EObject object, final BranchState state) {
    boolean _not = (!((state.hasComparisonAncestor() || state.hasFunctionDefinitionAncestor()) || state.hasFunctionCallAncestor()));
    if (_not) {
      this.error("Algebraic expressions must be nested within a comparison expression", null);
    }
  }
  
  @Check
  private void checkNumberLiteralIsExponentLiteral(final NumberLiteral numberLiteral, final BranchState state) {
    boolean _not = (!(state.hasSumAncestor() || state.isInPowerRightBranch()));
    if (_not) {
      this.error(
        "Number literals must be contained within a sum expression or the right operand of a power expression", numberLiteral, 
        ZeroKnowledgePackage.Literals.NUMBER_LITERAL__VALUE);
    }
  }
  
  @Check
  public void checking(final Model model) {
    final Procedure1<EObject> _function = (EObject node) -> {
      System.out.println(node.toString());
    };
    ModelMap.preorder(model.getProof(), _function);
  }
  
  public void checkNode(final EObject brackets, final BranchState state) {
    if (brackets instanceof Brackets) {
      _checkNode((Brackets)brackets, state);
      return;
    } else if (brackets instanceof Comparison) {
      _checkNode((Comparison)brackets, state);
      return;
    } else if (brackets instanceof Conjunction) {
      _checkNode((Conjunction)brackets, state);
      return;
    } else if (brackets instanceof Disjunction) {
      _checkNode((Disjunction)brackets, state);
      return;
    } else if (brackets instanceof FunctionCall) {
      _checkNode((FunctionCall)brackets, state);
      return;
    } else if (brackets instanceof Negative) {
      _checkNode((Negative)brackets, state);
      return;
    } else if (brackets instanceof NumberLiteral) {
      _checkNode((NumberLiteral)brackets, state);
      return;
    } else if (brackets instanceof Power) {
      _checkNode((Power)brackets, state);
      return;
    } else if (brackets instanceof Product) {
      _checkNode((Product)brackets, state);
      return;
    } else if (brackets instanceof StringLiteral) {
      _checkNode((StringLiteral)brackets, state);
      return;
    } else if (brackets instanceof Sum) {
      _checkNode((Sum)brackets, state);
      return;
    } else if (brackets instanceof Tuple) {
      _checkNode((Tuple)brackets, state);
      return;
    } else if (brackets instanceof Variable) {
      _checkNode((Variable)brackets, state);
      return;
    } else if (brackets instanceof FunctionDefinition) {
      _checkNode((FunctionDefinition)brackets, state);
      return;
    } else if (brackets instanceof Model) {
      _checkNode((Model)brackets, state);
      return;
    } else if (brackets instanceof Parameter) {
      _checkNode((Parameter)brackets, state);
      return;
    } else if (brackets instanceof ParameterList) {
      _checkNode((ParameterList)brackets, state);
      return;
    } else if (brackets instanceof Witness) {
      _checkNode((Witness)brackets, state);
      return;
    } else if (brackets instanceof WitnessList) {
      _checkNode((WitnessList)brackets, state);
      return;
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(brackets, state).toString());
    }
  }
}
